<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui"><title>Training Containerization</title><link rel="stylesheet" href="node_modules/reveal.js/dist/reset.css"><link rel="stylesheet" href="node_modules/reveal.js/dist/reveal.css"><link rel="stylesheet" href="assets/css/revealjs-theme.css" id="theme"><!--This CSS is generated by the Asciidoctor reveal.js converter to further integrate AsciiDoc's existing semantic with reveal.js--><style type="text/css">.reveal div.right {
  float: right
}

/* source blocks */
.reveal .listingblock.stretch > .content {
  height: 100%
}

.reveal .listingblock.stretch > .content > pre {
  height: 100%
}

.reveal .listingblock.stretch > .content > pre > code {
  height: 100%;
  max-height: 100%
}

/* auto-animate feature */
/* hide the scrollbar when auto-animating source blocks */
.reveal pre[data-auto-animate-target] {
  overflow: hidden;
}

.reveal pre[data-auto-animate-target] code {
  overflow: hidden;
}

/* add a min width to avoid horizontal shift on line numbers */
code.hljs .hljs-ln-line.hljs-ln-n {
  min-width: 1.25em;
}

/* tables */
table {
  border-collapse: collapse;
  border-spacing: 0
}

table {
  margin-bottom: 1.25em;
  border: solid 1px #dedede
}

table thead tr th, table thead tr td, table tfoot tr th, table tfoot tr td {
  padding: .5em .625em .625em;
  font-size: inherit;
  text-align: left
}

table tr th, table tr td {
  padding: .5625em .625em;
  font-size: inherit
}

table thead tr th, table tfoot tr th, table tbody tr td, table tr td, table tfoot tr td {
  display: table-cell;
  line-height: 1.6
}

td.tableblock > .content {
  margin-bottom: 1.25em
}

td.tableblock > .content > :last-child {
  margin-bottom: -1.25em
}

table.tableblock, th.tableblock, td.tableblock {
  border: 0 solid #dedede
}

table.grid-all > thead > tr > .tableblock, table.grid-all > tbody > tr > .tableblock {
  border-width: 0 1px 1px 0
}

table.grid-all > tfoot > tr > .tableblock {
  border-width: 1px 1px 0 0
}

table.grid-cols > * > tr > .tableblock {
  border-width: 0 1px 0 0
}

table.grid-rows > thead > tr > .tableblock, table.grid-rows > tbody > tr > .tableblock {
  border-width: 0 0 1px
}

table.grid-rows > tfoot > tr > .tableblock {
  border-width: 1px 0 0
}

table.grid-all > * > tr > .tableblock:last-child, table.grid-cols > * > tr > .tableblock:last-child {
  border-right-width: 0
}

table.grid-all > tbody > tr:last-child > .tableblock, table.grid-all > thead:last-child > tr > .tableblock, table.grid-rows > tbody > tr:last-child > .tableblock, table.grid-rows > thead:last-child > tr > .tableblock {
  border-bottom-width: 0
}

table.frame-all {
  border-width: 1px
}

table.frame-sides {
  border-width: 0 1px
}

table.frame-topbot, table.frame-ends {
  border-width: 1px 0
}

.reveal table th.halign-left, .reveal table td.halign-left {
  text-align: left
}

.reveal table th.halign-right, .reveal table td.halign-right {
  text-align: right
}

.reveal table th.halign-center, .reveal table td.halign-center {
  text-align: center
}

.reveal table th.valign-top, .reveal table td.valign-top {
  vertical-align: top
}

.reveal table th.valign-bottom, .reveal table td.valign-bottom {
  vertical-align: bottom
}

.reveal table th.valign-middle, .reveal table td.valign-middle {
  vertical-align: middle
}

table thead th, table tfoot th {
  font-weight: bold
}

tbody tr th {
  display: table-cell;
  line-height: 1.6
}

tbody tr th, tbody tr th p, tfoot tr th, tfoot tr th p {
  font-weight: bold
}

thead {
  display: table-header-group
}

.reveal table.grid-none th, .reveal table.grid-none td {
  border-bottom: 0 !important
}

/* kbd macro */
kbd {
  font-family: "Droid Sans Mono", "DejaVu Sans Mono", monospace;
  display: inline-block;
  color: rgba(0, 0, 0, .8);
  font-size: .65em;
  line-height: 1.45;
  background: #f7f7f7;
  border: 1px solid #ccc;
  -webkit-border-radius: 3px;
  border-radius: 3px;
  -webkit-box-shadow: 0 1px 0 rgba(0, 0, 0, .2), 0 0 0 .1em white inset;
  box-shadow: 0 1px 0 rgba(0, 0, 0, .2), 0 0 0 .1em #fff inset;
  margin: 0 .15em;
  padding: .2em .5em;
  vertical-align: middle;
  position: relative;
  top: -.1em;
  white-space: nowrap
}

.keyseq kbd:first-child {
  margin-left: 0
}

.keyseq kbd:last-child {
  margin-right: 0
}

/* callouts */
.conum[data-value] {
  display: inline-block;
  color: #fff !important;
  background: rgba(0, 0, 0, .8);
  -webkit-border-radius: 50%;
  border-radius: 50%;
  text-align: center;
  font-size: .75em;
  width: 1.67em;
  height: 1.67em;
  line-height: 1.67em;
  font-family: "Open Sans", "DejaVu Sans", sans-serif;
  font-style: normal;
  font-weight: bold
}

.conum[data-value] * {
  color: #fff !important
}

.conum[data-value] + b {
  display: none
}

.conum[data-value]:after {
  content: attr(data-value)
}

pre .conum[data-value] {
  position: relative;
  top: -.125em
}

b.conum * {
  color: inherit !important
}

.conum:not([data-value]):empty {
  display: none
}

/* Callout list */
.hdlist > table, .colist > table {
  border: 0;
  background: none
}

.hdlist > table > tbody > tr, .colist > table > tbody > tr {
  background: none
}

td.hdlist1, td.hdlist2 {
  vertical-align: top;
  padding: 0 .625em
}

td.hdlist1 {
  font-weight: bold;
  padding-bottom: 1.25em
}

/* Disabled from Asciidoctor CSS because it caused callout list to go under the
 * source listing when .stretch is applied (see #335)
 * .literalblock+.colist,.listingblock+.colist{margin-top:-.5em} */
.colist td:not([class]):first-child {
  padding: .4em .75em 0;
  line-height: 1;
  vertical-align: top
}

.colist td:not([class]):first-child img {
  max-width: none
}

.colist td:not([class]):last-child {
  padding: .25em 0
}

/* Override Asciidoctor CSS that causes issues with reveal.js features */
.reveal .hljs table {
  border: 0
}

/* Callout list rows would have a bottom border with some reveal.js themes (see #335) */
.reveal .colist > table th, .reveal .colist > table td {
  border-bottom: 0
}

/* Fixes line height with Highlight.js source listing when linenums enabled (see #331) */
.reveal .hljs table thead tr th, .reveal .hljs table tfoot tr th, .reveal .hljs table tbody tr td, .reveal .hljs table tr td, .reveal .hljs table tfoot tr td {
  line-height: inherit
}

/* Columns layout */
.columns .slide-content {
  display: flex;
}

.columns.wrap .slide-content {
  flex-wrap: wrap;
}

.columns.is-vcentered .slide-content {
  align-items: center;
}

.columns .slide-content > .column {
  display: block;
  flex-basis: 0;
  flex-grow: 1;
  flex-shrink: 1;
}

.columns .slide-content > .column > * {
  padding: .75rem;
}

/* See #353 */
.columns.wrap .slide-content > .column {
  flex-basis: auto;
}

.columns .slide-content > .column.is-full {
  flex: none;
  width: 100%;
}

.columns .slide-content > .column.is-four-fifths {
  flex: none;
  width: 80%;
}

.columns .slide-content > .column.is-three-quarters {
  flex: none;
  width: 75%;
}

.columns .slide-content > .column.is-two-thirds {
  flex: none;
  width: 66.6666%;
}

.columns .slide-content > .column.is-three-fifths {
  flex: none;
  width: 60%;
}

.columns .slide-content > .column.is-half {
  flex: none;
  width: 50%;
}

.columns .slide-content > .column.is-two-fifths {
  flex: none;
  width: 40%;
}

.columns .slide-content > .column.is-one-third {
  flex: none;
  width: 33.3333%;
}

.columns .slide-content > .column.is-one-quarter {
  flex: none;
  width: 25%;
}

.columns .slide-content > .column.is-one-fifth {
  flex: none;
  width: 20%;
}

.columns .slide-content > .column.has-text-left {
  text-align: left;
}

.columns .slide-content > .column.has-text-justified {
  text-align: justify;
}

.columns .slide-content > .column.has-text-right {
  text-align: right;
}

.columns .slide-content > .column.has-text-left {
  text-align: left;
}

.columns .slide-content > .column.has-text-justified {
  text-align: justify;
}

.columns .slide-content > .column.has-text-right {
  text-align: right;
}

.text-left {
  text-align: left !important
}

.text-right {
  text-align: right !important
}

.text-center {
  text-align: center !important
}

.text-justify {
  text-align: justify !important
}

.footnotes {
  border-top: 1px solid rgba(0, 0, 0, 0.2);
  padding: 0.5em 0 0 0;
  font-size: 0.65em;
  margin-top: 4em;
}

.byline {
  font-size:.8em
}
ul.byline {
  list-style-type: none;
}
ul.byline li + li {
  margin-top: 0.25em;
}
</style><link rel="stylesheet" href="assets/css/gepardec-custom.css"></head><body><div class="reveal"><div class="slides"><img src="assets/images/GEPARDEC_logo_RGB_hellerhg.svg" style="width: auto; height: 50px; position: fixed; top: 1px; right: 1px; z-index: -9999;" alt="gepardec logo"><section class="title" data-state="title" data-transition="zoom" data-transition-speed="fast" data-background-image="assets/images/gepard_white.png"><h1>Training Containerization</h1></section><section><section id="_gepardec_who"><h2>Gepardec who?</h2></section><section id="_thats_us" class="columns"><h2>That&#8217;s us</h2><div class="slide-content"><div class="ulist column"><ul><li><p>office: vienna / linz</p></li><li><p>size: ~ 40 people</p></li><li><p>we do what we love..</p><div class="ulist"><ul><li><p>custom software solution</p></li><li><p>cloud transformation</p></li><li><p>devOps automation</p></li></ul></div></li></ul></div>
<div class="imageblock column is-vcentered"><img src="assets/images/01_welcome/team.jpg" alt="team" width="700px"></div>
<table class="tableblock frame-none grid-none column" style="width:100%"><colgroup><col style="width:100%"></colgroup><tbody><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="assets/images/01_welcome/openshift.svg" alt="openshift" width="100px"></span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="assets/images/01_welcome/rh_premium_partner.jpg" alt="rh premium partner" width="150px"></span></p></td></tr><tr><td class="tableblock halign-left valign-top"><p class="tableblock"><span class="image"><img src="assets/images/01_welcome/jboss.svg" alt="jboss" width="150px"></span></p></td></tr></table>
<aside class="notes"><div class="ulist"><ul><li><p>Wir sind eine kleine Firma bestehend aus knapp 40 Mitarbeitern in Wien und Linz.</p></li><li><p>Wir sind auf custom software entwicklung spezialisiert mit einem zusätlichen Focus auf cloud transformation und devOps Automatisierung</p></li><li><p>Ich bin sehr stolz darauf, sagen zu können, dass wir im Beruf das machen, was uns begeistert.</p></li><li><p>Das macht uns zu einem ausgezeichneten Partner.</p></li></ul></div></aside></div></section><section id="_how_we_teach"><h2>How we teach</h2><div class="slide-content"><div class="ulist"><ul><li><p>Gepardec believes in <strong>learning by doing</strong></p></li><li><p>The training is <strong>lab driven</strong></p></li><li><p>Work together!</p></li><li><p>Ask questions at any time</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>This workshop is primarily exercise based</p></li><li><p>Lecture will be limited and focus on the high-level concepts, best practices, and ideas we want to tell you about</p></li><li><p>Most of our time will be spent on demo exercises, designed to illustrate the usage, syntax, and details of all the tools we explore, and map onto the learning objectives for each chapter</p></li></ul></div></aside></div></section><section id="_session_logistics"><h2>Session Logistics</h2><div class="slide-content"><div class="ulist"><ul><li><p>2 days duration</p></li><li><p>Mostly exercises</p></li><li><p>Regular breaks</p></li></ul></div></div></section><section id="_assumed_knowledge_and_requirements"><h2>Assumed knowledge and requirements</h2><div class="slide-content"><div class="ulist"><ul><li><p>Fmailiarity with Bash or Powershell</p></li><li><p>Bash Cheat sheet <a href="http://bit.ly/2mTQr8l">http://bit.ly/2mTQr8l</a></p></li></ul></div>
<aside class="notes"><div class="paragraph"><p>Basic familiarity with:</p></div>
<div class="ulist"><ul><li><p>Filesystem navigation and manipulation: ls, cd, mv, cp, rm</p></li><li><p>Tooling: ssh, top, chmod, curl, wget</p></li><li><p>Package management with apt</p></li><li><p>And powershell equivalents</p></li></ul></div></aside></div></section><section id="_your_lab_environment"><h2>Your lab environment</h2><div class="slide-content"><div class="ulist"><ul><li><p>You have been given an instance for use in the exercises</p></li><li><p>Ask the instructor for the credentials if you don&#8217;t have them already</p></li></ul></div></div></section><section id="_training_learning_objectives"><h2>Training learning objectives</h2><div class="slide-content"><div class="paragraph"><p>By the end of this training, trainess will be able to</p></div>
<div class="ulist"><ul><li><p>Asses the advantages of a containerized software development &amp; deployment</p></li><li><p>Use container engine features necessary for running containerized applications</p></li></ul></div></div></section></section>
<section><section id="_virtualization_vs_containerization"><h2>Virtualization vs Containerization</h2><div class="slide-content"><aside class="notes"><div class="paragraph"><p>An intro module to get students on message with what containerization is, and the priorities and concerns of distributed application dev and ops.</p></div></aside></div></section><section id="_what_we_want"><h2>What we want</h2><div class="slide-content"><div class="paragraph"><p>Ideal software should</p></div>
<div class="ulist"><ul><li><p>be modular and flexible (DEVs)</p></li><li><p>be easy to migrate (DEVOPS)</p></li><li><p>be easy to scale, monitor and lifecycle (OPS)</p></li><li><p>mitigate vulnerabilities (Security)</p></li><li><p>and run cheap (business)</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>Every stakeholder in the software supply chain has a set of priorities they&#8217;d like software to satisfy.</p></li><li><p>Developers want flexibility and choice in the components they build application out of; problems like vendor lock-in, technical debt, and tight coupling between components slows the development cycle down and can prevent developers from building the software they want.</p></li><li><p>Devops engineers in charge of building and maintaining CI/CD pipelines are primarily responsible for getting applications running across many environments; they&#8217;d like to be able to move software easily, and rely that tests passing in one environment won&#8217;t break in another.</p></li><li><p>Operations teams responsible for scaling, maintaining and monitoring software would like to be able to deploy applications easily across a datacenter, and know what to expect from those applications to make monitoring and maintenance simple.</p></li><li><p>Security teams want assurances that software not only minimizes attack surfaces, but has built-in failsafes to mitigate compromises when they occur.</p></li><li><p>Finally, business interests want to be able to do all of the above as cheaply as possible, by making most efficient use of the compute resources purchased to run it.</p></li><li><p>These are many and varied priorities - but containerization is such a success because it speaks to all of them.</p></li></ul></div></aside></div></section><section id="_virtualization"><h2>Virtualization</h2><div class="slide-content"><div class="imageblock"><img src="assets/images/02_virtualization_vs_containerization/pre-container.svg" alt="pre container"></div>
<aside class="notes"><div class="ulist"><ul><li><p>Without containerization, we can imagine a host that looks as such. The key feature of this diagram is that all the dependencies, configurations, and system resources for applications on this host are shared.</p></li><li><p>From the developer&#8217;s standpoint, an uncontainerized environment requires strict discipline to avoid tight coupling between components; it&#8217;s easy to develop your way into a state where changes to one component break another, and all components are affected by the environmental requirements of the others, complicating and hindering testing and development.</p></li><li><p>For a devops engineer, the shared host environment of these components also adds friction. Every environment in the CI pipeline has to reflect this stack of dependencies and configurations, which can be difficult to maintain and difficult to reproduce.</p></li><li><p>For operations personnel, the more tightly coupled different components become, the more difficult they can be to scale and monitor; tight couplings can make it complicated to understand what&#8217;s needed to relax a performance bottleneck or trace root causes of application failures.</p></li></ul></div></aside></div></section><section id="_containerization"><h2>Containerization</h2><div class="slide-content"><div class="imageblock"><img src="assets/images/02_virtualization_vs_containerization/post-container.svg" alt="post container"></div>
<aside class="notes"><div class="ulist"><ul><li><p>The fundamental insight of the containerization movement was similar to that of the real-life logistics chains from which containerization got its name: many problems are solved by strictly encapsulating software as we develop, migrate, and deploy it.</p></li><li><p>The key feature of a software container is that it is self-contained, all the way down to the OS filesystem; not only our executables, but all their configs and all their dependencies, and even the OS filesystem they run in, are captured in a container that can be moved as a complete unit.&lt;/li&gt;</p></li><li><p>Modern Linux and Windows kernels can even represent the host system differently to different containers, presenting them different network devices, process trees, filesystems and more; all you need installed on the host is the Docker engine.</p></li></ul></div></aside></div></section><section id="_rapid_development"><h2>Rapid development</h2><div class="slide-content"><div class="imageblock"><img src="assets/images/02_virtualization_vs_containerization/component-upgrade.svg" alt="component upgrade"></div>
<div class="paragraph"><p>Containers can be removed and replaced with a minimum of impact on their neighbors, increasing developer choice and speed.</p></div>
<aside class="notes"><div class="ulist"><ul><li><p>From the developer&#8217;s point of view, aggressive encapsulation equals speed and flexibility; since containers provide assurances that one component doesn&#8217;t affect another, developers can upgrade one component while remaining confident they won&#8217;t break others.</p></li><li><p>Remember that containers carry the full dependency stack of the application they&#8217;re designed to run, all the way down to the OS filesystem; this means that developers can use different stacks for different components, all on the same host with no chance of dependency conflicts.</p></li></ul></div></aside></div></section><section id="_smooth_migration"><h2>Smooth migration</h2><div class="slide-content"><div class="imageblock"><img src="assets/images/02_virtualization_vs_containerization/component-migration.svg" alt="component migration"></div>
<div class="paragraph"><p>Containers carry their environment and dependencies with them, simplifying and minimizing requirements on the hosts that run them.</p></div>
<aside class="notes"><div class="ulist"><ul><li><p>From the devops point of view, aggressive encapsulation equals smooth migrations; since containers carry everything they need with them, they impose relatively few requirements on the host that runs them. Hosts need only provide a compatible kernel and architecture, and a container engine; no application specific dependencies or environment configurations need be maintained across environments.</p></li><li><p>In this way, not only will a container that runs in dev likely run in prod, it will run the same way; containerized software passing tests in one environment has a better chance of passing tests in all environments, since environment matters comparatively little once we containerize our applications.</p></li></ul></div></aside></div></section><section id="_simple_sclae_mainenance"><h2>Simple sclae &amp; mainenance</h2><div class="slide-content"><div class="imageblock"><img src="assets/images/02_virtualization_vs_containerization/component-scalability.svg" alt="component scalability"></div>
<div class="paragraph"><p>Containers have private system resources, so a compromise in one does not affect the rest.</p></div>
<aside class="notes"><div class="ulist"><ul><li><p>From the point of view of operations personnel, the encapsulation provided by containers translates into simple methodology for scaling and maintaining applications.</p></li><li><p>Scale is achieved by containers in part by the minimal requirements they put on their environment; since containers are designed to run the same way regardless of their hosting environment, multiple instances can be spun up in parallel, or distributed across all the hosts in a datacenter.</p></li><li><p>Furthermore, a well-designed container should run only a very limited set of tasks; by avoiding tight coupling and defining relatively simple behaviors for each container, it becomes simpler to define what 'healthy' means for a container, compared to a complete host with many interacting processes.</p></li></ul></div></aside></div></section><section id="_secure_by_default"><h2>Secure by default</h2><div class="slide-content"><div class="imageblock"><img src="assets/images/02_virtualization_vs_containerization/component-isolation.svg" alt="component isolation"></div>
<div class="paragraph"><p>Containers have private system resources, so a compromise in one does not affect the rest.</p></div>
<aside class="notes"><div class="ulist"><ul><li><p>From the point of view of security, aggressive encapsulation automatically enhances our security posture.</p></li><li><p>On an uncontainerized host, if an attacker successfully compromises one component with elevated privileges, they can leverage those privileges across the entire host, using any vulnerable component as a point of ingress.</p></li><li><p>On the other hand, containerized software mitigates its own vulnerabilities; even if an attacker compromises one container via a vulnerable component, privileges gained there do not grant the same level of access to other containers or to the host; root in a container does not equal root on the host.</p></li></ul></div></aside></div></section><section id="_application_density"><h2>Application density</h2><div class="slide-content"><div class="imageblock"><img src="assets/images/02_virtualization_vs_containerization/component-density.svg" alt="component density"></div>
<div class="paragraph"><p>Containers save datacenter costs by running many more application instances than virtual machines can on the same physical hosts.</p></div>
<aside class="notes"><div class="ulist"><ul><li><p>In terms of operational costs, containers can radically reduce the amount of metal needed to run a given workload compared to a virtual machine, because they are so resource efficient; containerized processes use the host kernel and don&#8217;t require fixed allocations of CPU and memory, so can be run with the absolute minimal footprint.</p></li><li><p>It&#8217;s not unusual for the same datacenter to be able to run 10x as many containers encapsulating a given process, compared to VMs encapsulating the same software, resulting in substantial cost savings to users.</p></li></ul></div></aside></div></section></section>
<section><section id="_containerization_basics"><h2>Containerization basics</h2></section><section id="_discussion_running_containers"><h2>Discussion running containers</h2><div class="slide-content"><div class="paragraph"><p>What assurances would you need to run a process on an arbitrary host? Consider</p></div>
<div class="ulist"><ul><li><p>Hostile environments</p></li><li><p>Required resources</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>Guide the class to thinking about the need for process isolation (via kernel namespaces etc), filesystem provisioning (via Docker images), and resource consumption limitations (via cgroups)</p></li><li><p>Hint questions if the class is stuck:</p></li><li><p>Do you trust the other processes running on this host? Should they trust you? (leads to need for process isolation)</p></li><li><p>Will your process' dependencies be available on this host? Are you sure? (leads to need for docker images)</p></li><li><p>How much resources can you reasonably consume on this host? (leads to need for cgroup limitations)</p></li></ul></div></aside></div></section><section id="_learning_objectives"><h2>Learning objectives</h2><div class="slide-content"><div class="paragraph"><p>By the end of this module, trainees will be able to</p></div>
<div class="ulist"><ul><li><p>Describe what a container is in terms of processes and isolation tools</p></li><li><p>Use the key commands for interacting with Docker containers</p></li></ul></div></div></section><section id="_containers_are_processes"><h2>Containers are processes</h2><div class="slide-content"><div class="paragraph"><p><span class="keyword">Containers</span> are processes sandboxed by</p></div>
<div class="ulist"><ul><li><p>Kernel namespaces</p></li><li><p>Control Groups</p></li><li><p>Root priviledge management &amp; syscall restrictions (Linux)</p></li><li><p>VM isolation (Windows)</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>Fundamentally, containers are just processes living on the host, isolated primarily by kernel namespaces, and control groups for resource isolation.</p></li><li><p>Linux containers can also be subject to restrictions on what root privileges and system calls they are allowed to make, by application of a linux security module.</p></li><li><p>On the Windows side, containers enhance their isolation by running in ultra-light-weight VMs.</p></li></ul></div></aside></div></section><section id="_linux_kernel_namespaces"><h2>Linux kernel namespaces</h2><div class="slide-content"><div class="ulist"><ul><li><p>DEFAULT</p><div class="ulist"><ul><li><p>Process IDs</p></li><li><p>Network stacks</p></li><li><p>inter-process communications</p></li><li><p>Mount points</p></li><li><p>Hostnames</p></li></ul></div></li><li><p>OPTIONAL</p><div class="ulist"><ul><li><p>User IDs</p></li></ul></div></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>The baseline tool for creating containers is the kernel namespace. Kernel namespaces create distinct representations of things like PID trees, user spectra, network stacks and mount points; processes live in exactly one namespace, and are only able to interact with the broader system via the representation encapsulated therein.</p></li><li><p>By analogy: an un-namespaced system is like when airplanes used to have just one TV in the cabin everyone would look up at to watch the in-flight movie. Everyone shared the device, and everyone saw the same thing.</p></li><li><p>Introducing namespaces is like putting seatback TVs in front of every passenger. Now everyone has their own private devices and sees their own thing, which is hidden from their neighbors.</p></li><li><p>In the same way, a namespaced process has all their own resources - their own iptables rules and eth0 device, their own mount points, their own PID tree - and processes in other namespaces aren&#8217;t allowed to touch or even see these resources.</p></li></ul></div></aside></div></section><section id="_linux_pid_kernel_namespace"><h2>Linux PID kernel namespace</h2><div class="slide-content"><div class="imageblock"><img src="assets/images/03_containerization_basics/pid-tree.svg" alt="pid tree" width="50%"></div>
<aside class="notes"><div class="ulist"><ul><li><p>For example, PID namespaces make the first process in the namespace appear as the root of a process tree to all other processes in that namespace, which will be its children.</p></li><li><p>Meanwhile, processes in the parent namespace see these processes with PID numbers like any other process in the parent PID namespace.</p></li><li><p>In this way, processes in the child namespace aren&#8217;t able to find information about processes in the parent namespace, but the child namespace remains transparent from the perspective of the parent namespace.</p></li><li><p>Stopping the PID 1 of a child namespace and stopping the container are the exact same thing.</p></li><li><p>Isolating host system resources, rather than creating a whole new virtual machine, is where the high performace of containers comes from. Think of it like building a little wall around a patch of sand in a sandbox; the area marked off can itself be thought of as a new sandbox, but no new sand has been acquired.</p></li></ul></div></aside></div></section><section id="_optional_linux_isolation_features"><h2>Optional Linux isolation features</h2><div class="slide-content"><div class="ulist"><ul><li><p>Control groups: limit memory &amp; CPU</p></li><li><p>Root priviledge management: acceptlist root powers</p></li><li><p>System call management: acceptlist available system calls</p></li><li><p>Linux Security Modules: mandatory filesystem access control</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>In addition to the default kernel namespaces, a number of other linux technologies can be imposed on your containers to restrict their privileges.</p></li><li><p>All production deployments should take advantage of control groups, to limit how much memory and CPU a container can consume.</p></li><li><p>Root privileges and system calls are governed by whitelist, which can be configured per-container</p></li><li><p>Linux security modules allow the creation of access control rules for filesystem paths and objects within the container.</p></li></ul></div></aside></div></section><section id="_instructor_demo_process_isolation" class="dark_background demo background"><h2><span class="icon moby_icon"><img src="assets/icons/task.png" alt="task"></span> Instructor demo: Process isolation</h2><div class="slide-content"><div class="paragraph"><p>See the demo</p></div>
<div class="ulist"><ul><li><p>Process isolation</p></li></ul></div>
<div class="paragraph"><p>in the exercise book</p></div></div></section><section id="_exercise_container_basics" class="dark_background exercise background"><h2><span class="icon moby_icon"><img src="assets/icons/task.png" alt="task"></span> Exercise: Container Basics</h2><div class="slide-content"><div class="paragraph"><p>Work through</p></div>
<div class="ulist"><ul><li><p>Running and inspecting a container</p></li><li><p>Interactive containers</p></li><li><p>Detached containers and Logging</p></li><li><p>Starting, stopping, inspecting and deleting cotnainers</p></li></ul></div>
<div class="paragraph"><p>In the exercise book.</p></div>
<h2 id="exercise_container_basics" class="timer"></h2></div></section><section id="_container_lifecycle"><h2>Container lifecycle</h2><div class="slide-content"><div class="imageblock"><img src="assets/images/03_containerization_basics/container-lifecycle.svg" alt="container lifecycle"></div>
<aside class="notes"><div class="ulist"><ul><li><p>The rectangles display the state of the container and the arrow labels show the Docker command used to change the container state.</p></li><li><p>The container lifecycle always begins in the CREATED state. A container in this state has a private filesystem set up on disk (more on this in the next chapter) and metadata defined regarding what process it is to encapsulate and how, but it not yet running. When the process in question begins running, the container transitions to the UP state.</p></li><li><p>If a containerized process exits, the container transitions to the EXITED state. It can normally be restarted with a start command.</p></li><li><p>Finally, Docker containers can enter a PAUSED state of suspension imposed by control group freezing. This suspension technique (unlike using SIGSTOP and SIGCONT) can&#8217;t be caught by the process, ensuring that pausing a container doesn&#8217;t disrupt the process it containerizes.</p></li></ul></div></aside></div></section><section id="_container_logs"><h2>Container logs</h2><div class="slide-content"><div class="ulist"><ul><li><p>STOUD and STERR for a container process</p></li><li><p><code>docker container logs &lt;container_name&gt;</code></p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>STDOUT and STDERR of whatever process is PID 1 in a container are logged by Docker, and available via <code>docker container logs</code></p></li></ul></div></aside></div></section><section id="_container_basics_takeaways"><h2>Container basics takeaways</h2><div class="slide-content"><div class="ulist"><ul><li><p>Single process constrained by kernel namespaces, control groups and other Linux technologies</p></li><li><p>Private &amp; ephemeral filesystem and data</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>The key conceptual take-aways for container basics are the first two points; the container&#8217;s main process, which it labels PID 1, will stop the container when it itself stops; and writing to the container&#8217;s file system writes only to that container, not the underlying image; soon we&#8217;ll learn more about these underlying images, and how to manipulate them.</p></li><li><p>Everything else we learned in this unit is basic creation, deletion and investigation syntax.</p></li></ul></div></aside></div></section><section id="_further_reading"><h2>Further reading</h2><div class="slide-content"><div class="ulist"><ul><li><p>List of container commands: <a href="http://dockr.ly/2iLBV2I">http://dockr.ly/2iLBV2I</a></p></li><li><p>Getting started with containers: <a href="http://dockr.ly/2gmxKWB">http://dockr.ly/2gmxKWB</a></p></li><li><p>Start containers automatically: <a href="http://dockr.ly/2xB8sMl">http://dockr.ly/2xB8sMl</a></p></li><li><p>Limit a container&#8217;s resources: <a href="http://dockr.ly/2wqN5Nn">http://dockr.ly/2wqN5Nn</a></p></li><li><p>Isolate containers with a user namespace: <a href="http://dockr.ly/2gmyKdf">http://dockr.ly/2gmyKdf</a></p></li><li><p>Keep containers alive during daemon downtime: <a href="http://dockr.ly/2emLwb5">http://dockr.ly/2emLwb5</a></p></li><li><p>Intro to Windows Containers: <a href="https://dockr.ly/2CTYhYb">https://dockr.ly/2CTYhYb</a></p></li></ul></div>
<aside class="notes"><div class="paragraph"><p>additional resources about containers</p></div></aside></div></section></section>
<section><section id="_container_images"><h2>Container images</h2><div class="slide-content"><aside class="notes"><div class="ulist"><ul><li><p>In our discussion of containers, we focused on how processes are isolated.</p></li><li><p>But if a process is to be truly portable, it also needs its filesystem and dependencies to come along with it.</p></li><li><p>In this module, we&#8217;ll explore images in-depth, including a focus on creating and modifying images.</p></li></ul></div></aside></div></section><section id="_discussion_provisioning_filesystems"><h2>Discussion: provisioning filesystems</h2><div class="slide-content"><div class="paragraph"><p>What are some potential difficulties with provisioning entire filesystems for containers?<br>
How can we avoid these problems?</p></div>
<aside class="notes"><div class="ulist"><ul><li><p>Guide the class to thinking about some of the non-obvious nuances around building and sharing images</p></li><li><p>Obvious answer: disk and bandwidth usage</p></li><li><p>Hint questions if the class is stuck:</p></li><li><p>Are all container filesystems necessarily unique? If two containers share a filesystem, how will they remain independent? (leads to layer sharing and read-only images)</p></li><li><p>What&#8217;s a simple way to minimize the risk of vulnerable components making it onto your production servers via a Docker image? (answer: don&#8217;t install any component you don&#8217;t absolutely need, indicates the logic of minimal images)</p></li><li><p>If containers and their filesystems are meant to move across environments like dev, testing, staging and prod without needing to be modified, how can they reflect the important differences between those environments? (leads to motivating multi-stage builds)</p></li></ul></div></aside></div></section><section id="_learning_objectives_2"><h2>Learning objectives</h2><div class="slide-content"><div class="paragraph"><p>By the end of this module, trainess will be able to</p></div>
<div class="ulist"><ul><li><p>Create container images via several methods</p></li><li><p>Describe the filesystem structure underlying a container image</p></li><li><p>Understand the performance implications of different container image design decisions</p></li><li><p>Correctly tag and namespace container images for distribution via a registry</p></li></ul></div></div></section><section id="_what_are_container_images" class="columns"><h2>What are container images?</h2><div class="slide-content"><div class="ulist column"><ul><li><p>A <span class="keyword">filesystem</span> for container processes</p></li><li><p>Made of a stack of <span class="keyword">immutable</span> layers</p></li><li><p>Start with a <span class="keyword">base image</span></p></li><li><p>New layer for each change</p></li></ul></div>
<div class="imageblock column"><img src="assets/images/04_container_images/image-layered-fs.svg" alt="image layered fs"></div>
<aside class="notes"><div class="ulist"><ul><li><p>Images are composed in layers; each layer consists of a bunch of files that capture how this layer adapts the one beneath it.</p></li><li><p>Note: On Windows there are also Windows registy entries that are captured as part of the layer.</p></li><li><p>These stacks of layers always start with a base image, which typically captures only the base operating system for this image.</p></li><li><p>each subsequent image layer captures sequential changes to the image.</p></li></ul></div></aside></div></section><section id="_sharing_layers"><h2>Sharing layers</h2><div class="slide-content"><div class="imageblock"><img src="assets/images/04_container_images/image-shared-layers.svg" alt="image shared layers"></div>
<aside class="notes"><div class="paragraph"><p>benefits of layering (see if students can guess):</p></div>
<div class="ulist"><ul><li><p>Sharing layers == smaller on disk and in memory</p></li><li><p>Sharing layers == faster downloads (de-duped by default)</p></li><li><p>Allows caching when constructing images</p></li></ul></div></aside></div></section><section id="_the_writable_container_layer"><h2>The writable container layer</h2><div class="slide-content"><div class="imageblock"><img src="assets/images/04_container_images/image-container-layer.svg" alt="image container layer"></div>
<aside class="notes"><div class="ulist"><ul><li><p>Starting a container essentially adds a single writable layer to the image stack; since Docker is just adding this one thin layer, container startup is very fast and resource efficient.</p></li><li><p>Any manipulations of the filesystem a container does is written only to this R/W layer; all image layers are always read-only.</p></li><li><p>When a container edits a file from the base image, then and only then is that file copied to the R/W layer; this is what is meant by Docker&#8217;s 'copy on write' filesystem; this also implies that the copy of a file that is visible in a running container is whichever copy of that file sits highest in the stack of filesystem layers.</p></li></ul></div></aside></div></section><section id="_images_copy_on_write"><h2>Images: Copy on write</h2><div class="slide-content"><div class="imageblock"><img src="assets/images/04_container_images/image-copy-on-write.svg" alt="image copy on write"></div>
<aside class="notes"><div class="ulist"><ul><li><p>The final product is composed per this diagram, via what we call a 'copy on write' composition strategy</p></li><li><p>Each time a layer is added, only files that are changed are copied up to the next layer; each of these layers actually exists as a directory on your host machine.</p></li></ul></div></aside></div></section><section id="_linux_containers_union_fs"><h2>Linux Containers: Union FS</h2><div class="slide-content"><div class="imageblock"><img src="assets/images/04_container_images/image-union-fs.svg" alt="image union fs"></div>
<aside class="notes"><div class="ulist"><ul><li><p>When creating a container on Linux, a R/W container layer is created, and all these filesystem layers are composed via a union filesystem mount. This assembles the image layers into a unified filesystem similar to superimposing a stack of overhead transparencies on top of each other; files on higher layers obscure earlier versions of themselves on lower layers.</p></li><li><p>When a container modifies a file from the image, it performs the same copy on write action as above, into the R/W container layer.</p></li></ul></div></aside></div></section><section id="_creating_images"><h2>Creating images</h2><div class="slide-content"><div class="paragraph"><p>Three methods:</p></div>
<div class="ulist"><ul><li><p><span class="keyword">Commit</span> the R/W container layer as a new R/O container image layer.</p></li><li><p>Define layers to add to a existing container image in a <span class="keyword">Containerfile</span>.</p></li><li><p><span class="keyword">Import</span> a traball into as a standalone base image.</p></li></ul></div></div></section><section id="_commiting_container_changes"><h2>Commiting container changes</h2><div class="slide-content"><div class="ulist"><ul><li><p><code>docker container commit</code> saves the container layer as a new R/O container image layer</p></li><li><p>Pro: build container images interactively</p></li><li><p>Con: hard to reproduce or audit; <span class="keyword">avoid this</span> in pratice</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>One way of building up images is to save the container layer as a new image layer</p></li><li><p>This is fine for experiments, but it&#8217;s really something best avoided in the development of production grade code, since it isn&#8217;t easily auditable, reproducible or automated.</p></li></ul></div></aside></div></section><section id="_containerfiles"><h2>Containerfiles</h2><div class="slide-content"><div class="ulist"><ul><li><p>Content manifest</p></li><li><p>Provides container image layer documentation</p></li><li><p>Enable automation (CI/CD)</p></li><li><p><span class="keyword">FROM</span> command defines the base image</p></li><li><p>Each subsequent command adds a layer of metadata</p></li><li><p><code>docker image build &#8230;&#8203;</code> builds container image Containerfile</p></li></ul></div>
<div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-Dockerfile hljs" data-noescape="true" data-lang="Dockerfile"># Comments begin with the pound sign
FROM ubuntu:16.04
RUN apt-get update &amp;&amp; apt-get install -y wget
ADD /data /myapp/data</code></pre></div></div>
<aside class="notes"><div class="ulist"><ul><li><p>Interactive image creation is good for tinkering, but its main drawback is that it doesn&#8217;t produce an artifact describing the steps to create the image in a machine-readable way.</p></li><li><p>Therefore, there&#8217;s no way to build images this way as part of a CI/CD chain, and it can be hard to audit what exactly is in the image.</p></li><li><p>A Dockerfile is essentially a recipe to build an image, layer by layer. This can be ingested in build processes and CI/CD pipelines, and preserves a record of all the steps taken to create an image.</p></li><li><p>Note that dockerfiles for linux and windows are syntactically identical; they use different images for their bases and run different processes at each step, but the way we specify our image recipe doesn&#8217;t change at all.</p></li></ul></div></aside></div></section><section id="_instructor_demo_creating_images" class="dark_background demo background"><h2><span class="icon moby_icon"><img src="assets/icons/task.png" alt="task"></span> Instructor demo: Creating images</h2><div class="slide-content"><div class="paragraph"><p>See the demo</p></div>
<div class="ulist"><ul><li><p>Creating images</p></li></ul></div>
<div class="paragraph"><p>in the exercise book.</p></div></div></section><section id="_exercise_creating_images" class="dark_background exercise background"><h2><span class="icon moby_icon"><img src="assets/icons/task.png" alt="task"></span> Exercise: Creating images</h2><div class="slide-content"><div class="paragraph"><p>Work through</p></div>
<div class="ulist"><ul><li><p>Interactive Image Creation</p></li><li><p>Creating Images with Dockerfiles (1/2)</p></li></ul></div>
<div class="paragraph"><p>in the exercise book.</p></div>
<h2 id="exercise_container_images" class="timer"></h2></div></section><section id="_build_cache"><h2>Build cache</h2><div class="slide-content"><div class="imageblock"><img src="assets/images/04_container_images/image-build-cache.svg" alt="image build cache" width="20%"></div>
<div class="paragraph"><p>After completion, the resulting container images layer is labeled with a hash of the content of all current image layer in the stack.</p></div>
<aside class="notes"><div class="ulist"><ul><li><p>Layers are fetched from the cache via the hash label affixed to that layer the first time it was created.</p></li><li><p>Q: Why is a hash for a layer computed based on the entire image? Why not just that layer?</p></li><li><p>A: A layer can&#8217;t be reused unless all layers under it are the same; put another way, the effect of whatever command generated the layer might be different depending on substrate layers.</p></li><li><p>The upshot being that the builder will stop using the cache at the first change in the Dockerfile.</p></li></ul></div></aside></div></section><section id="_cmd_and_entrypoint"><h2>CMD and ENTRYPOINT</h2><div class="slide-content"><div class="ulist"><ul><li><p>Recall all container run a process as their PID 1</p></li><li><p><span class="keyword">CMD</span> and <span class="keyword">ENTRYPOINT</span> allow us to specify default processes</p></li><li><p><span class="keyword">CMD</span> alone: default command ans list of parameters.</p></li><li><p><span class="keyword">CMD</span> &amp; <span class="keyword">ENTRYPOINT</span> provides command, <span class="keyword">CMD</span> provides default parameters.</p></li><li><p><span class="keyword">CMD</span> overridden by command argument to <code>docker container run</code></p></li><li><p><span class="keyword">ENTRYPOINT</span> overriden via <code>--entrypoint</code> flag to <code>docker container run</code>.</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>Another pair of helpful commands in Dockerfiles are CMD and ENTRYPOINT</p></li><li><p>These are used for specifying default processes and options to run in containers created from this image.</p></li><li><p>Oftentimes images are designed to do exactly one thing; CMD and ENTRYPOINT allow you to bake that intention right into the image, by pre-specifying that command.</p></li><li><p>The difference between the two is essentially in how you want to override these defaults</p></li><li><p>Using them together makes your container feel a lot like an executable; arguments (defaulted by CMD) will be overridden by command line args, but the executable defined by ENTRYPOINT will not.</p></li></ul></div></aside></div></section><section id="_shell_vs_exec_format"><h2>Shell vs Exec format</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-Dockerfile hljs" data-noescape="true" data-lang="Dockerfile"># Shell form
CMD sudo -u ${USER} java ...

# Exec form
CMD ["sudo", "-u", "jdoe", "java", ...]</code></pre></div></div>
<aside class="notes"><div class="ulist"><ul><li><p>CMD, ENTRYPOINT and RUN commands can use either exec or shell syntax</p></li><li><p>If we have a command like this on Windows <code>powershell New-Item c:\test</code> then if it is in declared in shell form what is executed is in reality <code>cmd /S /C powershell New-Item c:\test</code> whilst in exec form the command is executed as is without the use of the shell (cmd in this case). The analogous is true for Linux containers.</p></li><li><p>exec is generally preferred for ENTRYPOINT, since it preserves the ability to override options.</p></li><li><p>subtle differences:</p><div class="ulist"><ul><li><p><code>Shell form</code> allows for the parsing of variables like `CMD sudo -u ${USER} java &#8230;&#8203; `</p></li><li><p><code>Exec form</code> can run in a container with no shell; shell form always runs via <code>/bin/sh -c</code></p></li><li><p><code>Shell form</code> for <code>ENTRYPOINT</code> prevents options from being overridden by <code>CMD</code> or <code>docker container run</code>.</p></li></ul></div></li><li><p>Note that exec form is formal JSON - double quotes mandatory.</p></li><li><p>When using the shell form, the specified binary is executed with an invocation of the shell using /bin/sh -c, which means the process running as PID 1 is the /bin/sh executable.</p></li></ul></div></aside></div></section><section id="_exercise_containerfiles_22" class="dark_background exercise background"><h2><span class="icon moby_icon"><img src="assets/icons/task.png" alt="task"></span> Exercise: Containerfiles (2/2)</h2><div class="slide-content"><div class="paragraph"><p>Work through</p></div>
<div class="ulist"><ul><li><p>Creating Images with Dockerfiles (2/2)</p></li></ul></div>
<div class="paragraph"><p>in the exercise book.</p></div>
<h2 id="exercise_container_images_container_files_2" class="timer"></h2></div></section><section id="_copy_and_add_commands"><h2>COPY and ADD commands</h2><div class="slide-content"><div class="paragraph"><p><span class="keyword">COPY</span> copies files from build context to container image</p></div>
<div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-Dockerfile hljs" data-noescape="true" data-lang="Dockerfile">COPY &lt;src&gt; &lt;dest&gt;</code></pre></div></div>
<div class="paragraph"><p><span class="keyword">ADD</span> can also <span class="keyword">untar</span>* or <span class="keyword">fetch URLs</span>.</p></div>
<div class="paragraph"><p><span class="comment">* Linux containers only!</span></p></div>
<div class="ulist"><ul><li><p>create checksum for files added</p></li><li><p>log checksum in build cache</p></li><li><p>cache invalidated if checksum changed</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>COPY and ADD add files from the local filesystem to the image</p></li><li><p>Build process uses a checksum against the files to be added to bust the cache if those files have changed</p></li><li><p>Note that ADD can also copy files from a URL and for Linux containers only(!) untar files upon copying them into the image.</p></li></ul></div></aside></div></section><section id="_containerfile_command_roundup"><h2>Containerfile command roundup</h2><div class="slide-content"><div class="ulist"><ul><li><p><span class="keyword">FROM</span>: base image to start fron (usually OS)</p></li><li><p><span class="keyword">RUN</span>: run a command in the environment defined so far</p></li><li><p><span class="keyword">CMD</span> &amp; <span class="keyword">ENTRYPOINT</span>: define default behaviour</p></li><li><p><span class="keyword">COPY</span> &amp; <span class="keyword">ADD</span>: copy files into container</p></li></ul></div>
<div class="paragraph"><p>Many more Containerfile commands are available; see the docs at <a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a></p></div>
<aside class="notes"><div class="paragraph"><p>We&#8217;ve seen the greatest hits of Dockerfile commands, but there are tons more; see the docs.&lt;</p></div></aside></div></section><section id="_advanced_containerfile_construction"><h2>Advanced Containerfile construction</h2><div class="slide-content"><div class="paragraph"><p>How can we build container images that are</p></div>
<div class="ulist"><ul><li><p>Lighweight</p></li><li><p>Secure</p></li><li><p>Minimal build times</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>Now that we&#8217;ve seen the basics of image construction with Dockerfiles, we&#8217;d like to investigate best practices around image construction</p></li><li><p>Our priorities for image creation are size, security, and build times.</p></li><li><p>Size and security can be addressed by similar techniques; making sure we only install things we absolutely need in our image not only keeps the image size down, but avoids exposing ourselves to potential vulnerabilities in superfluous components.</p></li><li><p>Also during the course of development, we&#8217;d like build times to be as fast as possible, either by leveraging the cache we&#8217;ve already seen, or by parallelizing parts of the build process.</p></li><li><p>For the next part of this chapter, we&#8217;ll look at some advanced techniques for achieving all of these.</p></li></ul></div></aside></div></section><section id="_the_scratch_container_image"><h2>The scratch container image</h2><div class="slide-content"><div class="ulist"><ul><li><p>An "empty" image</p></li><li><p>Can&#8217;t be pulled</p></li><li><p>Doesn&#8217;t create a layer</p></li><li><p>Used for building container image not based on any pre-existing container image</p></li><li><p>Linux only</p></li></ul></div>
<div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-Dockerfile hljs" data-noescape="true" data-lang="Dockerfile">FROM scratch

ADD centos-7-docker.tar.xz /

LABEL org.label-schema.schema-version="1.0" \
org.label-schema.name="CentOS Base Image" \
org.label-schema.vendor="CentOS" \
org.label-schema.license="GPLv2" \
org.label-schema.build-date="20181205"

CMD ["/bin/bash"]</code></pre></div></div>
<aside class="notes"><div class="ulist"><ul><li><p>The scratch image is an empty image that exists in Docker Hub, but has no tags and can&#8217;t be pulled.</p></li><li><p>When used in a Dockerfile, the line <code>FROM scratch</code> doesn&#8217;t add any layer to the image. The next command in the Dockerfile will be the first filesystem layer.</p></li><li><p>The scratch image is used typically to build base images with as few components as possible installed in them, to give the smallest possible attack surface to our images.</p></li></ul></div></aside></div></section><section id="_multi_stage_builds_12"><h2>Multi-Stage builds (1/2)</h2><div class="slide-content"><div class="paragraph"><p>Hello worls, in C:</p></div>
<div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-Dockerfile hljs" data-noescape="true" data-lang="Dockerfile">FROM alpine:3.5
RUN apk update &amp;&amp; \
    apk add --update alpine-sdk
RUN mkdir /app
WORKDIR /app
ADD hello.c /app
RUN mkdir bin
RUN gcc -Wall hello.c -o bin/hello
CMD /app/bin/hello</code></pre></div></div>
<div class="paragraph"><p>Builds to:</p></div>
<div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-shell hljs" data-noescape="true" data-lang="shell">$ docker image ls hwc
REPOSITORY      TAG             IMAGE ID        CREATED         SIZE
hwc             latest          142c29686b6a    15 hours ago    184 MB</code></pre></div></div>
<aside class="notes"><div class="ulist"><ul><li><p>Here&#8217;s a Dockerization of hello world, in C. By now, we should recognize the steps: we start from an operating system, use RUN to install dependencies, ADD to import files from our host machine, and define some default behavior with CMD.</p></li><li><p>There&#8217;s just one problem: we have successfully made a hello world application in a mere 184 MB. Giant images are at best slow to start, and can have security problems depending on what unnecessary components have been included.</p></li><li><p>Most of this bloat is due to things we don&#8217;t actually need in production: compilers, developer tools and the like.</p></li><li><p>The Docker image builder implements Multi Stage Builds to allow you to create executables, then throw away the scaffolding needed to compile them, leaving you with a fast, lightweight image.</p></li></ul></div></aside></div></section><section id="_multi_stage_builds_22"><h2>Multi-Stage builds (2/2)</h2><div class="slide-content"><div class="paragraph"><p>Hello worls, in C:</p></div>
<div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-Dockerfile hljs" data-noescape="true" data-lang="Dockerfile"># Full SDK version (built and discarded)
FROM alpine:3.5 AS build
RUN apk update &amp;&amp; \
    apk add --update alpine-sdk
RUN mkdir /app
WORKDIR /app
ADD hello.c /app
RUN mkdir bin
RUN gcc -Wall hello.c -o bin/hello

# Lightweight image returned as final product
FROM alpine:3.5
COPY --from=build /app/bin/hello /app/hello
CMD /app/hello</code></pre></div></div>
<div class="paragraph"><p>Builds to:</p></div>
<div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-shell hljs" data-noescape="true" data-lang="shell">$ docker image ls hwc
REPOSITORY      TAG             IMAGE ID        CREATED         SIZE
hwc             latest          5d925cfc9c96    39 seconds ago  4MB</code></pre></div></div>
<aside class="notes"><div class="ulist"><ul><li><p>To make a lightweight version of hello world with all the developer tools stripped out, we start with the exact same Dockerfile, but we&#8217;ve added the AS clause to the FROM statement.</p></li><li><p>Then, we&#8217;ve added a second stanza, where we start from the same OS, but instead of installing the developer&#8217;s kit, we use the --from flag with COPY to reference the 'build' image described above, and copy just the final executable over into our final image.</p></li><li><p>The --from flag to COPY can also also specify an earlier image by index counting from 0 (so --from=0 would have had the same effect in the second stanza above).</p></li><li><p>Note that it kind of looks like we built two images here - in fact, only the final FROM stanza results in an image on disk. All previous stanzas create cached image layers, but no final image.</p></li></ul></div></aside></div></section><section id="_build_target"><h2>Build target</h2><div class="slide-content"><div class="paragraph"><p>Containerfile</p></div>
<div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-Dockerfile hljs" data-noescape="true" data-lang="Dockerfile">FROM &lt;base image&gt; as base
...

FROM &lt;foo image&gt; as foo
...

FROM &lt;bar image&gt; as bar
...

FROM alpine:3.4
...
COPY --from foo ...
COPY --from bar ...
...</code></pre></div></div>
<div class="paragraph"><p>building the container image</p></div>
<div class="paragraph"><p><code>docker image build --tag &lt;name&gt; &#8230;&#8203;</code></p></div>
<aside class="notes"><div class="ulist"><ul><li><p>We can also build intermediate images by specifying the "--target" parameter with the name of the intermediate build.</p></li><li><p>If no "--target" is provided then the "docker image build" command always builds only the last image (the one starting with the last FROM statement in the Dockerfile)</p></li><li><p>The &lt;name&gt; of an intermediate image is either the index of the FROM in the Dockerfile or the alias provided in the FROM statement (e.g. FROM base as test - in that case &lt;name&gt; would be "test")</p></li></ul></div></aside></div></section><section id="_exercise_multi_stage_builds" class="dark_background exercise background"><h2><span class="icon moby_icon"><img src="assets/icons/task.png" alt="task"></span> Exercise: Multi-Stage Builds</h2><div class="slide-content"><div class="paragraph"><p>Work through</p></div>
<div class="ulist"><ul><li><p>Multi-Stage Builds</p></li></ul></div>
<div class="paragraph"><p>in the exercise book.</p></div>
<h2 id="exercise_cotnainer_images_multi_stage_builds" class="timer"></h2></div></section><section id="_container_image_construction_best_practices"><h2>Container image construction best practices</h2><div class="slide-content"><div class="ulist"><ul><li><p>Start with an official container image</p></li><li><p>Use multi-stage builds to drop compilers, SDKs, &#8230;&#8203;</p></li><li><p>More layers leverage the cache</p></li><li><p>&#8230;&#8203;but fewer layers perform better</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>Now that we have the mechanics of making Dockerfiles, there&#8217;s also a number of optional best practices to consider.</p></li><li><p>Base your images off of official images whenever possible; you can recognize these on Docker Hub as they don&#8217;t have an explicit namespace like vendor/product; they&#8217;re just single-word names, possibly with a tag. These are all battle-tested images produced in collaboration between the product vendors and Docker, and are scanned regularly for security vulnerabilities.</p></li><li><p>Take advantage of multi-stage builds; these allow you to drop unnecessary layers, which will result in faster container start times, and less components that potentially inject vulnerabilities into your containers.</p></li><li><p>Deciding how many layers to build an image out of depends on your priorities. The fundamental tension is that more layers leverage the cache better (since hopefully you don&#8217;t invalidate the cache until you&#8217;re most of the way through your Dockerfile), but this creates more overhead at container runtime, which you may wish to avoid for production images.</p></li></ul></div></aside></div></section><section id="_development_more_layers" class="columns"><h2>Development: More layers</h2><div class="slide-content"><div class="openblock column"><div class="content"><div class="paragraph"><p>Bad caching:</p></div>
<div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-Dockerfile hljs" data-noescape="true" data-lang="Dockerfile">FROM python:3.5-alpine
RUN mkdir /app
COPY /mypy /app/
RUN pip install -r app/reqs.txt
...</code></pre></div></div></div></div>
<div class="openblock column"><div class="content"><div class="paragraph"><p>Good caching:</p></div>
<div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-Dockerfile hljs" data-noescape="true" data-lang="Dockerfile">FROM python:3.5-alpine
RUN mkdir /app
COPY /mypy/reqs.txt /app/
RUN pip install -r app/reqs.txt
COPY /mypy /app/
...</code></pre></div></div></div></div>
<aside class="notes"><div class="ulist"><ul><li><p>A common best practice during development is to split up oft-changing and rarely-changing elements into different layers. Move the rarely-changing parts as high as possible in the Dockerfile, so they don&#8217;t have to be redone when the frequently changing parts are changed.</p></li><li><p>In this case, we save ourselves from redoing the <code>pip install</code> when anything other than the requirements file changes.</p></li></ul></div></aside></div></section><section id="_production_less_layers"><h2>Production: Less layers</h2><div class="slide-content"><div class="ulist"><ul><li><p>To collapse ALL image layer:</p></li></ul></div>
<div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-shell hljs" data-noescape="true" data-lang="shell">$ docker container run -d --name demo mytallimage:1.0
$ docker container export demo &gt; image.tar
$ cat image.tar | docker image import - myflatimage:1.0</code></pre></div></div>
<div class="ulist"><ul><li><p>Or build with <code>--squash</code> flag (experimental): compress all non-base-layers</p></li><li><p>Use <code>container export --squash</code> for one shareable base layer &amp; one application layer</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>Once it&#8217;s time to go to production (or even to start CI/CD), we don&#8217;t care so much about build times and caching. The image is nominally built - what matters is performance.</p></li><li><p>One way to compress everything into a single layer is to export a container as a tarball, and reimport it as a new, single layer image. This completely destroys the ability of containers to share layers, though</p></li><li><p>Another method is the experimental squash flag, which combines all non-base layers into a single layer. Now the base layer remains sharable, and our production image is only two layers.</p></li><li><p>One technique for getting the best of both worlds when layer sharing is important is to use the first method to collapse all widely shared layers into a common base image, and then use the --squash flag on subsequent builds to squash the application-unique layers into a single application layer.</p></li></ul></div></aside></div></section><section id="_best_practices_patching_updates"><h2>Best practices: Patching &amp; Updates</h2><div class="slide-content"><div class="imageblock"><img src="assets/images/04_container_images/image-good-bad-layering.svg" alt="image good bad layering"></div>
<aside class="notes"><div class="ulist"><ul><li><p>When revving an image, don&#8217;t just apply patches on top of old images. If it&#8217;s your base layer that&#8217;s been revved, the vendor will likely release a new image corresponding to the new software version; update your Dockerfile and rebuild your image with the new base layer.</p></li><li><p>The same logic holds true for updating other image layers; rebuild your image from its Dockerfile, pulling in the desired versions of your dependencies, rather than just installing patches on top of patches like you would for software installed on the host.</p></li><li><p>*Remember copy on write: when you apply a patch, it doesn&#8217;t overwrite whatever its upgrading; all versions of all files are persisted in their entirety in an ever-growing image layer stack. This will bloat your images and slow down their performance.</p></li></ul></div></aside></div></section><section id="_container_image_tags"><h2>Container Image tags</h2><div class="slide-content"><div class="ulist"><ul><li><p>Optional string after image name, separated by <code>:</code></p></li><li><p><code>:latest</code> by default</p></li><li><p>Same image with two tags share same ID, image layer:</p></li></ul></div>
<div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-shell hljs" data-noescape="true" data-lang="shell">$ docker image ls centos*
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
centos              7                   8140d0c64310        7 days ago          193 MB
$ docker image tag centos:7 centos:mytag
$ docker image ls centos*
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
centos              7                   8140d0c64310        7 days ago          193 MB
centos              mytag               8140d0c64310        7 days ago          193 MB</code></pre></div></div>
<aside class="notes"><div class="ulist"><ul><li><p>In addition to the name of the image, images can be given an optional tag.</p></li><li><p>Tags are often used to capture version number or base image distro.</p></li><li><p>The tag will default to <code>latest</code> if omitted.</p></li><li><p>Note that tags are essentially just pointers to an image which is uniquely identified by its ID; creating another tag pointing to the same image doesn&#8217;t duplicate the image on disk, but just creates another reference to it.</p></li></ul></div></aside></div></section><section id="_container_image_namespaces"><h2>Container Image namespaces</h2><div class="slide-content"><div class="paragraph"><p>Container images exist in one of three namespaces:</p></div>
<div class="ulist"><ul><li><p>Root (<span class="keyword">ubuntu, nginx, mongo, mysql</span>,&#8230;&#8203;)</p></li><li><p>User / Org (<span class="keyword">jdoe/myapp:1.1</span>, <span class="keyword">microsoft/nanoserver:latest</span>,&#8230;&#8203;)</p></li><li><p>Registry (<span class="keyword">FQDN/jdoe/myapp:1.1</span>)</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>Certified images produced in collaboration between Docker and third-party software vendors are given single-word names in the root namespace.</p></li><li><p>Images meant to be shared on hub.docker.com are namespaced via the owning account, then the image name</p></li><li><p>Images stored in docker trusted registry are similar to hub.docker.com names, but prefixed with the FQDN of the registry.</p></li></ul></div></aside></div></section><section id="_image_tagging_namespacing"><h2>Image tagging &amp; namespacing</h2><div class="slide-content"><div class="ulist"><ul><li><p>Tag on build: <code>docker image build -t myapp:1.0 .</code></p></li><li><p>Retag an exisitng image: <code>docker image tag myapp:1.0 me/myapp:2.0</code></p></li><li><p>Note <code>docker image tag</code> can set both tag and namespace</p></li><li><p>Names and tags are just pointers to container image ID</p></li><li><p>Container Image ID corresponds to immutable content addressable storage</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>Images can be tagged on build or retagged at any time.</p></li><li><p>Always remember that an image must be namespaced correctly to push to a registry, whether it&#8217;s hub.docker.com or Docker Trusted Registry.</p></li><li><p>Finally, remember that docker registries all use content addressable storage models; image names and tags are really just human-friendly pointers to image IDs, which serve as the true address for immutable image information. As such, it is a good security strategy to pull by sha and not by tag; then you always know exactly what you&#8217;re getting.</p></li></ul></div></aside></div></section><section id="_sharing_container_images"><h2>Sharing container images</h2><div class="slide-content"><div class="ulist"><ul><li><p>Docker HUB</p><div class="ulist"><ul><li><p>Provides certified commercial and free software distributed as Docker Images</p></li><li><p>Shares community-generated container images and content</p></li></ul></div></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>Docker Hub allows you to access and share your public repositories with the Docker community at large. You can download two types of images from the Docker Hub: Docker Verified Images and Community/Hub images.</p></li><li><p>Docker Hub is a cloud-based registry service which allows you to link to code repositories, build your images and test them, stores manually pushed images, and links to Docker Cloud so you can deploy images to your hosts. If you have built images, you can push them to a Docker Hub repository that you add to your Docker Hub user or organization account.</p></li></ul></div></aside></div></section><section id="_exercise_managing_container_images" class="dark_background exercise background"><h2><span class="icon moby_icon"><img src="assets/icons/task.png" alt="task"></span> Exercise: Managing container images</h2><div class="slide-content"><div class="paragraph"><p>Work through</p></div>
<div class="ulist"><ul><li><p>Managing Images</p></li></ul></div>
<div class="paragraph"><p>in the exercise book.</p></div>
<h2 id="exercise_cotnainer_images_mmanaging_images" class="timer"></h2></div></section><section id="_container_image_creation_takeaways"><h2>Container Image Creation takeaways</h2><div class="slide-content"><div class="ulist"><ul><li><p>Container images are built out of R/O layers.</p></li><li><p>Containerfiles specify container image layer contents</p></li><li><p>Key Containerfile commands: <span class="keyword">FROM, RUN, COPY</span> and <span class="keyword">ENTRYPOINT</span></p></li><li><p>Container images must be namepsaced accoriding to where you intend on sharing them</p></li></ul></div></div></section><section id="_further_reading_2"><h2>Further reading</h2><div class="slide-content"><div class="ulist"><ul><li><p>Best practices for writing Dockerfiles: <a href="http://dockr.ly/22WiJiO">http://dockr.ly/22WiJiO</a>link:</p></li><li><p>Use multi-stage builds: <a href="http://dockr.ly/2ewcUY3">http://dockr.ly/2ewcUY3</a></p></li><li><p>More about images, containers, and storage drivers: <a href="http://dockr.ly/1TuWndC">http://dockr.ly/1TuWndC</a></p></li><li><p>Details on image layering: <a href="https://bit.ly/2AHX7iW">https://bit.ly/2AHX7iW</a></p></li><li><p>Graphdriver plugins: <a href="http://dockr.ly/2eIVCab">http://dockr.ly/2eIVCab</a></p></li><li><p>Docker Reference: An Intro to Storage Solutions for Docker CaaS: <a href="http://dockr.ly/2x8sBw2">http://dockr.ly/2x8sBw2</a></p></li><li><p>How to select a storage driver: <a href="http://dockr.ly/2eDu8yO">http://dockr.ly/2eDu8yO</a></p></li><li><p>Use the AUFS storage driver: <a href="http://dockr.ly/2jVc1Zz">http://dockr.ly/2jVc1Zz</a></p></li><li><p>User guided caching in Docker: <a href="http://dockr.ly/2xKafPf">http://dockr.ly/2xKafPf</a></p></li></ul></div>
<aside class="notes"><div class="paragraph"><p>additional resources about creating images for Linux</p></div></aside></div></section></section>
<section><section id="_container_volumes"><h2>Container Volumes</h2></section><section id="_discussion_managing_data"><h2>Discussion: Managing data</h2><div class="slide-content"><div class="paragraph"><p>If a container generates at lot of data, where should it be stored?<br>
What if you need to provision data to a container?</p></div>
<aside class="notes"><div class="ulist"><ul><li><p>Guide the class to thinking about the fact that so far, containers and images don&#8217;t provide a practical way to manage data that lives longer than the lifetime of a container.</p></li><li><p>Hint questions if the class is stuck:</p></li><li><p>Should you write a lot of data to the container layer? That&#8217;s currently the only place we&#8217;ve learned about in this workshop where you can write data to at container run time. Why wouldn&#8217;t you want to do this?</p></li><li><p>Should you provision data to a container by including that data in the underlying image? Again, this is the only option we&#8217;ve seen so far. Why wouldn&#8217;t you want to do this?</p></li></ul></div></aside></div></section><section id="_learning_objectives_3"><h2>Learning objectives</h2><div class="slide-content"><div class="paragraph"><p>By the end of this module, trainees will be able to</p></div>
<div class="ulist"><ul><li><p>Define a volume and identify its primary use cases</p></li><li><p>Describe advantages and potential secuity risks of mounting volumes and host directories</p></li></ul></div></div></section><section id="_volume_usecases"><h2>Volume usecases</h2><div class="slide-content"><div class="paragraph"><p>Volumes provide a R/W path <span class="keyword">separate from the layered filesystem</span>.</p></div>
<div class="ulist"><ul><li><p><span class="keyword">Mount</span> data at container startup</p></li><li><p><span class="keyword">Persist</span> data when a container is deleted</p></li><li><p><span class="keyword">Share</span> data between containers</p></li><li><p><span class="keyword">Speed up</span> I/O by circumventing the union filesystem</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>Volumes primarily provide a way to handle data that has a longer lifecycle than an individual container, by providing a writable location separate from the container&#8217;s union filesystem.</p></li><li><p>For example, if a container needs access to a large body of files, those files can be mounted into a running container as a volume, avoiding the need to create a (potentially huge) image with that data baked in.</p></li><li><p>If a container is creating or collecting data as it runs, it should be stored in a volume, since that volume will survive the deletion of the container.</p></li><li><p>Furthermore, volumes can be a more performant choice for write heavy workloads for the same reason. Rather than searching the layers of the union filesystem and performing a copy on write operation when writing a file, I/O in a volume simply reads and writes the relevant file, without the added overhead.</p></li></ul></div></aside></div></section><section id="_basic_volumes"><h2>Basic volumes</h2><div class="slide-content"><div class="ulist"><ul><li><p><span class="keyword">Named</span>: managed by Docker; filesystem independent; user-specified identifier</p></li><li><p><span class="keyword">Anonymous</span>: managed by Docker; filesystem independent; randomly-generated identifier</p></li><li><p><span class="keyword">Host mounted</span>: mount a specific path on the host; DIY management</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>There are two high-level methods for mounting volumes into containers: named volumes, and host mounts.</p></li><li><p>In the named volume case, Docker will create and manage a directory on your host for your volume, using the 'docker volume' CLI commands.</p></li><li><p>Host mounts specify a particular path on the host to mount into a container. This is useful if there&#8217;s something host specific you want to provide to the container, but requires you to manage the host&#8217;s filesystem directly and depends on the path in question actually being meaningful on that host, potentially affecting portability.</p></li></ul></div></aside></div></section><section id="_instructor_demo_volumes" class="dark_background demo background"><h2><span class="icon moby_icon"><img src="assets/icons/task.png" alt="task"></span> Instructor demo: Volumes</h2><div class="slide-content"><div class="paragraph"><p>See the demo</p></div>
<div class="ulist"><ul><li><p>Basic Volume Usage</p></li></ul></div>
<div class="paragraph"><p>in the exercise book.</p></div></div></section><section id="_volumes_in_containerfile"><h2>Volumes in Containerfile</h2><div class="slide-content"><div class="ulist"><ul><li><p><span class="keyword">VOLUME</span> instructions creates a mount point</p></li><li><p>Can specify arguments in a JSON array or string</p></li><li><p>Cannot map volumes to host directories</p></li><li><p>Volumes are initialized when the container is executed</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>VOLUME is another Dockerfile instruction available to designate a directory inside a container as a volume to be persisted on the host.</p></li><li><p>Note that this syntax does not allow for the specification of a host path, since that would break our all-important portability; there&#8217;s no guarantee that path will exist on any arbitrary machine in a meaningful way.</p></li><li><p>Docker automatically creates a volume (directory) on the host for each volume that is declared in the Dockerfile. The name of such a host volume is a sha256. The data that is then stored inside those volumes inside the container is mapped/persisted to the host FS.</p></li></ul></div></aside>
<div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-noescape="true" data-lang="dockerfile">FROM nginx:latest
...
# string example
VOLUME /myvolume

# string example with multiple volumes
VOLUME /www/website1 /www/website2

# JSON example
VOLUME ["myvol1", "myvol2"]
...</code></pre></div></div></div></section><section id="_volumes_and_security"><h2>Volumes and security</h2><div class="slide-content"><div class="ulist"><ul><li><p>Point of ingress to the host and other containers</p></li><li><p>Don&#8217;t mount things unnecessarily</p></li><li><p>Use the <span class="keyword">:ro</span> flag whenever possible</p></li><li><p>Linu: in-memory <span class="keyword">tmpfs</span> mounts available</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>Volumes are the first thing we&#8217;ve seen so far that pierce the isolation we carefully crafted between containers, the host, and other containers. A malicious actor can inject files from one container to another, and to the host, if care is not taken.</p></li><li><p>Mount volumes and directories only as needed, and use the :ro flag when a container is only a passive consumer of data. Better yet, ask if there&#8217;s a way to separate out reader and writer containers, to keep write access to volumes as tightly restricted as possible.</p></li><li><p>Also for those running linux hosts, it&#8217;s also possible to mount purely in-memory volumes to a container; anything written here will never be written to disk, and will be released when the container is deleted. This is a good option for persisting sensitive data while a container is running.</p></li></ul></div></aside></div></section><section id="_exercise_volumes_usecases" class="dark_background exercise background"><h2><span class="icon moby_icon"><img src="assets/icons/task.png" alt="task"></span> Exercise: Volumes usecases</h2><div class="slide-content"><div class="paragraph"><p>Work through</p></div>
<div class="ulist"><ul><li><p>Database Volumes</p></li></ul></div>
<div class="paragraph"><p>in the exercise book.</p></div>
<h2 id="exercise_container_volumes_database" class="timer"></h2></div></section><section id="_container_volumes_takeaways"><h2>Container volumes takeaways</h2><div class="slide-content"><div class="ulist"><ul><li><p>Volumes persist data beyond the container lifecycle</p></li><li><p>Volumes bypass the copy-ob-write system (better for write-heavy containers)</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>The most important take home message for volumes, is that this is where persistent data should go - not in containers, which come and go rapidly.</p></li><li><p>Also, volumes are separate from the union file system; changes to volumes do not precipitate changes to images, and vice versa.</p></li></ul></div></aside></div></section><section id="_further_reading_3"><h2>Further reading</h2><div class="slide-content"><div class="ulist"><ul><li><p>How to use volumes: <a href="http://dockr.ly/2vRZBDG">http://dockr.ly/2vRZBDG</a></p></li><li><p>Troubleshoot volume errors: <a href="http://dockr.ly/2vyjvbP">http://dockr.ly/2vyjvbP</a></p></li><li><p>Docker volume reference: <a href="http://dockr.ly/2ewrlew">http://dockr.ly/2ewrlew</a></p></li></ul></div>
<aside class="notes"><div class="paragraph"><p>additional resources about volumes</p></div></aside></div></section></section>
<section><section id="_docker_system_commands"><h2>Docker system commands</h2><div class="slide-content"><aside class="notes"><div class="ulist"><ul><li><p>So far, we&#8217;ve encountered commands to interact with individual images and containers; in practice however, a Docker workflow will generate a lot of containers and images.</p></li><li><p>In this module, we&#8217;ll introduce some tools for managing your entire collection of images and containers on a node.</p></li></ul></div></aside></div></section><section id="_learning_objectives_4"><h2>Learning objectives</h2><div class="slide-content"><div class="paragraph"><p>By the end of this module, trainees will be able to</p></div>
<div class="ulist"><ul><li><p>Execut cleanup commands</p></li><li><p>Locate Docker system information</p></li></ul></div></div></section><section id="_cleanup_commands"><h2>Cleanup commands</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-shell hljs" data-noescape="true" data-lang="shell">$ docker system df
TYPE           TOTAL    ACTIVE   SIZE        RECLAIMABLE
Images         39       2        9.01 GB     7.269 GB (80%)
Containers     2        2        69.36 MB    0 B</code></pre></div></div>
<div class="ulist"><ul><li><p><code>docker system prune</code></p></li></ul></div>
<div class="paragraph"><p>more limited&#8230;&#8203;</p></div>
<div class="ulist"><ul><li><p><code>docker image prune [--filter "foo=bar"]</code></p></li><li><p><code>docker container prune [--filter "foo=bar"]</code></p></li><li><p><code>docker volume prune [--filter "foo=bar"]</code></p></li><li><p><code>docker network prune [--filter "foo=bar"]</code></p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>under heavy use the docker host might consume a load of resources or disk space. To find out with type of elements occupy how much space we can use the <code>docker system df</code> command. It tells us exactly how much space images, container and volumes currently occupy and how much of it is claimable.</p></li><li><p>to claim back unused space from the Docker host we can use the command <code>docker system prune</code>. It will try to remove dangling images, stopped containers and unused volumes and networks in one go.</p></li><li><p>we also have the more specialized <code>prune`</code> commands that only remove unused items of the given type</p></li><li><p>Prune commands can also be filtered by label in all cases, before a timestamp via 'until' for everything but volumes, and also by 'dangling' for images, for even more restricted pruning.</p></li></ul></div></aside></div></section><section id="_inspect_the_system"><h2>Inspect the system</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-shell hljs" data-noescape="true" data-lang="shell">$ docker system info
Containers: 2
 Running: 2
 Paused: 0
 Stopped: 0
Images: 105
Server Version: 17.03.0-ee
Storage Driver: overlay2
 Backing Filesystem: extfs
 Supports d_type: true
 Native Overlay Diff: true
Logging Driver: json-file
Cgroup Driver: cgroupfs
Plugins:
 Volume: local
 Network: bridge host ipvlan macvlan null overlay
Swarm: active
 NodeID: ybmqksh6fm627armruq0e8id1
 Is Manager: true
 ClusterID: 2rbf1dv6t5ntro2fxbry6ikr3
 Managers: 1
 Nodes: 1
 Orchestration:
  Task History Retention Limit: 5
 Raft:
  Snapshot Interval: 10000
  Number of Old Snapshots to Retain: 0
  Heartbeat Tick: 1</code></pre></div></div>
<aside class="notes"><div class="ulist"><ul><li><p>We can use the <code>docker system info</code> command to get very detailed information about the current Docker host. This information includes but is not limited to images, containers, swarm mode, networks and volumes.</p></li><li><p>When looking at the output, can you identify:</p><div class="ulist"><ul><li><p>how many images are on your machine?</p></li><li><p>What version of containerd are you running?</p></li><li><p>Whether Docker is running in swarm mode?</p></li></ul></div></li></ul></div></aside></div></section><section id="_system_events"><h2>System events</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-shell hljs" data-noescape="true" data-lang="shell">$ docker system events
2017-01-25T16:57:48.553596179-06:00 container create 30eb630790d44052f26c1081...
2017-01-25T16:57:48.556718161-06:00 container attach 30eb630790d44052f26c1081...
2017-01-25T16:57:48.698190608-06:00 network connect de1b2b40f522e69318847ada3...
2017-01-25T16:57:49.062631155-06:00 container start 30eb630790d44052f26c1081d...
2017-01-25T16:57:49.164526268-06:00 container die 30eb630790d44052f26c1081dbf...
2017-01-25T16:57:49.613422740-06:00 network disconnect de1b2b40f522e69318847a...
2017-01-25T16:57:49.815845051-06:00 container destroy 30eb630790d44052f26c108...</code></pre></div></div>
<div class="paragraph"><p>Generates events with <code>docker container run --rm apline echo 'Hello world'</code></p></div>
<aside class="notes"><div class="ulist"><ul><li><p><code>docker system info</code> gave us some mostly-static metadata about our docker platform; if we want to watch things live, we can take advantage of Docker&#8217;s event reporting via <code>docker system events</code>.</p></li><li><p>please note that the output generated by the <code>docker system events</code> command can also be filtered and custom formatted by using according command arguments <code>--filter</code> and <code>format</code></p></li><li><p>Image from <span class="image"><img src="http://www.bing.com/src/modules/06-system-commands/images/search?view=detailV2&amp;ccid=xHDtNSak&amp;id=F6B851CB5DF9FCB90FD4C4FBF86073617E979328&amp;q=monitoring&amp;simid=608004200364248188&amp;selectedIndex=0&amp;qft=+filterui%3alicense-L1+filterui%3aimagesize-medium&amp;ajaxhist=0" alt="search?view=detailV2&amp;ccid=xHDtNSak&amp;id=F6B851CB5DF9FCB90FD4C4FBF86073617E979328&amp;q=monitoring&amp;simid=608004200364248188&amp;selectedIndex=0&amp;qft=+filterui%3alicense L1+filterui%3aimagesize medium&amp;ajaxhist=0"></span></p></li></ul></div></aside></div></section><section id="_exercise_system_commands" class="dark_background exercise background"><h2><span class="icon moby_icon"><img src="assets/icons/task.png" alt="task"></span> Exercise: System commands</h2><div class="slide-content"><div class="paragraph"><p>Work through</p></div>
<div class="ulist"><ul><li><p>Cleaning up Docker resources</p></li><li><p>Inspecting Commands</p></li></ul></div>
<div class="paragraph"><p>in the exercise book.</p></div>
<h2 id="exercise_docker_system_commands" class="timer"></h2></div></section><section id="_discussion"><h2>Discussion</h2><div class="slide-content"><div class="ulist"><ul><li><p>What is the origin of dangling container image layers?</p></li><li><p>What are potential pitfalls automating system cleanup, and how can we avoid them?</p></li><li><p>Questions?</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>When a layer is no longer part of any tagged image, typically happens when a name and tag is reused after changing a Dockerfile.</p></li><li><p>Deleting containers without grabbing their logs first, deleting volumes that have valuable info just because they weren&#8217;t currently attached to anything. Avoid by using label-based filters when pruning.</p></li></ul></div></aside></div></section><section id="_further_reading_4"><h2>Further reading</h2><div class="slide-content"><div class="ulist"><ul><li><p>System commands reference: <a href="http://dockr.ly/2eMR53i">http://dockr.ly/2eMR53i</a></p></li></ul></div></div></section></section>
<section id="_containerization_fundementals_conclusion_any_app_anywhere"><h2>Containerization fundementals conclusion: Any app, anywhere</h2><div class="slide-content"><div class="ulist"><ul><li><p>Containers are isolated processes</p></li><li><p>Container images provide filesystem for containers</p></li><li><p>Volumes persist data</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>the key takehome from basic containerization is an understanding of how it lets docker deliver on its promise to enable you to run any app, anywhere.</p></li><li><p>the layered filesystems defined by Dockerfiles which in turn define images contain all the execution context a process needs to run; features of the linux kernel like kernel namespacing and control groups allow that environment to be created as a container on any host linux system, securely and without regard to whatever else is running on that machine. These tools provide the standardization and encapsulation we predicted would be of benefit in the introduction at the start of the day.</p></li><li><p>One slightly subtler point is that in none of this did we ever impose any restrictions on how many containers could be running on a given machine, or any necessary connections between the images that underlie them. This ability to mix and match frees us from correlations between processes; run your postgres database from ubuntu, your node.js web app from debian and your FORTRAN data wrangling from centos if you want - all on the same machine. Containerization&#8217;s implicit win is the ability to always use the right tool for the job.</p></li></ul></div></aside></div></section>
<section><section id="_wrap_up_quarkus_hello_world"><h2>Wrap up - Quarkus Hello-world</h2></section><section id="_exercise_instructions" class="dark_background exercise background"><h2><span class="icon moby_icon"><img src="assets/icons/task.png" alt="task"></span> Exercise instructions</h2><div class="slide-content"><div class="ulist"><ul><li><p><span class="keyword">Goal:</span> Build a docker image that runs a Java application</p></li><li><p>Find the fat jar <code>hello-world-&lt;version&gt;-runner.jar</code> in the zip you downloaded</p></li><li><p>Run the application with <code>java –jar hello-world-&lt;version&gt;-runner.jar</code>.</p></li><li><p>Try it out via <span class="keyword"><a href="http://localhost:8080/" class="bare">http://localhost:8080/</a></span></p></li></ul></div>
<div class="paragraph"><p>Considerations:</p></div>
<div class="ulist"><ul><li><p>What container image is suitable?</p></li><li><p>Do you need <span class="keyword">CMD</span>, or <span class="keyword">ENTRYPOINT</span>, or maybe both?</p></li><li><p>If you run two containers, what do need to take care of?</p></li></ul></div>
<h2 id="exercise_wrap_up_hello_world" class="timer"></h2></div></section><section id="_solution"><h2>Solution</h2><div class="slide-content"><div class="paragraph"><p>Sample Containerfile</p></div>
<div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-dockerfile hljs" data-noescape="true" data-lang="dockerfile">FROM anapsix/alpine-java
LABEL MAINTAINER=thomas.herzo@gepardec.com
WORKDIR /data
EXPOSE 8080
COPY build/libs/hello-world-&lt;version&gt;-runner.jar hello-world-&lt;version&gt;-runner.jar
CMD ["-jar", "hello-world-&lt;version&gt;-runner.jar"]
ENTRYPOINT ["java"]</code></pre></div></div>
<div class="paragraph"><p>Solution commands</p></div>
<div class="ulist"><ul><li><p><code>docker build -t hello_world .</code></p></li><li><p><code>docker run -d -p 8080:8080 hello_world</code></p></li></ul></div></div></section></section>
<section><section id="_container_networking_basics"><h2>Container networking basics</h2><div class="slide-content"><aside class="notes"><div class="ulist"><ul><li><p>[Instructor aside: this module is intended to bridge between one day of introduction to containerization, and one day of introduction to orchestration. As such it can equally well go at the end of the first or the beginning of the second, or be omitted entirely if the workshop isn&#8217;t introducing orchestration].</p></li><li><p>To begin our exploration of orchestration, we first need to examine the basics of how two containers can be networked together on a single host.</p></li></ul></div></aside></div></section><section id="_disciussion_portable_networks"><h2>Disciussion: Portable networks</h2><div class="slide-content"><div class="paragraph"><p>Network traffic must by efinition traverse a network outside its origination container.<br>
How can we make inter-container communication as portable and secure as containers themselves?</p></div>
<aside class="notes"><div class="ulist"><ul><li><p>Lead the class to think about the need for networking abstractions, both software defined networks and DNS-resolvable container names.</p></li><li><p>Hint questions if the class is stuck:</p></li><li><p>Can we rely on a container having the same IP or mac address every time it is created, no matter what host it is created on? (obviously not, a given private IP could already be taken on a destination host, and any global public identifier like a public IP or mac address couldn&#8217;t be practically registered at container run time). Therefore, we must need some sort of networking layer that abstracts away the host network. That also might give us the opportunity to impose some security on our networks, since we control this extra networking layer.</p></li><li><p>How will service discovery work in our containerized application logic? We&#8217;d like to avoid having a lot of boilerplate that exposes the networking underlay to our application logic; Docker should provide some portable addressing mechanism. (leads to thinking about DNS).</p></li></ul></div></aside></div></section><section id="_learning_objectives_5"><h2>Learning objectives</h2><div class="slide-content"><div class="paragraph"><p>By the end of this module, trainees will be able to</p></div>
<div class="ulist"><ul><li><p>Describe Docker&#8217;s container network model and its security implications</p></li><li><p>Describe the basic technologies that underwrite single host networks</p></li><li><p>Understand how Docker manipulates a host&#8217;s firewall rules to control container traffic</p></li></ul></div></div></section><section id="_the_container_network_model"><h2>The container network model</h2><div class="slide-content"><div class="imageblock"><img src="assets/images/09_networking_basics/container-networking-model.svg" alt="container networking model"></div>
<aside class="notes"><div class="ulist"><ul><li><p>At high level, docker thinks about networking with an abstraction called the Container Network Model (CNM) that consists of 3 parts:</p></li><li><p>The container (network) sandbox, which firewalls containers by default.</p></li><li><p>The network endpoint, which serves as a controlled port in and out of the container sandbox</p></li><li><p>The network itself, which is any device that facilitates inter-container communication.</p></li><li><p>If you think about it for a moment, the CNM is in some sense very vague; anything that satisfies these requirements is a valid implementation option. Just like we saw with containerization itself, Docker leverages battle-tested kernel features and linux tools to realize the CNM in practice.</p></li></ul></div></aside></div></section><section id="_linux_default_single_host_network"><h2>Linux: Default single-host network</h2><div class="slide-content"><div class="imageblock"><img src="assets/images/09_networking_basics/linux-single-host-network.svg" alt="linux single host network"></div>
<aside class="notes"><div class="ulist"><ul><li><p>When Docker is started on the host, a linux bridge is created by default, and assigned an unused private subnet from 172.[17-31].0.0/16 or 192.168.[0-240].0/20. A linux bridge is an in-software switch, that routes packets by MAC address.</p></li></ul></div></aside></div></section><section id="_linux_default_container_networking"><h2>Linux: Default container networking</h2><div class="slide-content"><div class="paragraph"><p><span class="image"><img src="assets/images/09_networking_basics/linux-default-container-networking.svg" alt="linux default container networking"></span></p></div>
<div class="paragraph"><p><span class="keyword">Quiz:</span> identify the sandbox, endpoint and network corresponding to the container networking model objects in this diagram.</p></div>
<aside class="notes"><div class="ulist"><ul><li><p>When a container is created, the container networking model must be satisfied. Containers run in their own network namespace, satisfying the sandboxing requirement; inside the namespace, processes won&#8217;t be able to access host networking devices unless explicitly connected to them.</p></li><li><p>In order to connect a container to the rest of the system, a virtual ethernet (veth) pair is created, with one endpoint connected to the default docker bridge, and the other presented as an ethX port inside the container with a private IP taken from the bridge&#8217;s subnet. Veth connections operate as a pipe, forwarding all traffic in one end to the other, even across network namespaces.</p></li></ul></div></aside></div></section><section id="_linux_user_defined_bridges_firewalls"><h2>Linux: User-defined bridges &amp; firewalls</h2><div class="slide-content"><div class="paragraph"><p><span class="image"><img src="assets/images/09_networking_basics/linux-custom-container-networking.svg" alt="linux custom container networking"></span></p></div>
<aside class="notes"><div class="ulist"><ul><li><p>Users can optionally create their own linux bridges, and plug containers into them for communicating on the same host.</p></li><li><p>Containers on user-created bridge networks can resolve each other by container name; containers names are registered in the Docker daemon&#8217;s DNS table for resolution.</p></li><li><p>You&#8217;ll build something like this in the next exercise.</p></li></ul></div></aside></div></section><section id="_exposing_container_ports"><h2>Exposing container ports</h2><div class="slide-content"><div class="ulist"><ul><li><p>Containers have no public IP address by default.</p></li><li><p>Can forward host port &#8594; container port</p></li><li><p>Mapping created manually or automatically.</p></li><li><p>Port mappings visible via
<code>docker container ls</code> or
<code>docker container port</code></p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>An axiom of Docker security can be thought of as 'isolated by default'</p></li><li><p>In terms of networking, this implies that containers are not reachable from the outside world by default.</p></li><li><p>Port mappings have to be set up if a containerized process is to be reachable directly.</p></li></ul></div></aside></div></section><section id="_instructor_demo_single_host_networks" class="dark_background demo background"><h2><span class="icon moby_icon"><img src="assets/icons/task.png" alt="task"></span> Instructor demo: Single host networks</h2><div class="slide-content"><div class="paragraph"><p>See the demo</p></div>
<div class="ulist"><ul><li><p>Single host netowrks</p></li></ul></div>
<div class="paragraph"><p>in the exercise book.</p></div></div></section><section id="_exercise_single_host_networks" class="dark_background exercise background"><h2><span class="icon moby_icon"><img src="assets/icons/task.png" alt="task"></span> Exercise: Single host networks</h2><div class="slide-content"><div class="paragraph"><p>Work through</p></div>
<div class="ulist"><ul><li><p>Introduction to Container Networking</p></li><li><p>Container Port Mapping</p></li></ul></div>
<div class="paragraph"><p>in the exercise book.</p></div>
<h2 id="exercise_networking_host_networks" class="timer"></h2></div></section><section id="_container_networking_takeaways"><h2>Container networking takeaways</h2><div class="slide-content"><div class="ulist"><ul><li><p>Single host networks follow the container networking model:</p><div class="ulist"><ul><li><p>Sandbox: Network namespaces</p></li><li><p>Endpoint: veth (linux)</p></li><li><p>Network: bridge (linux)</p></li></ul></div></li><li><p>Containers resolve each other by DNS lookup when named and attached to custom networks</p></li><li><p>Docker software defined networks are firewalled from each other by default</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>The key takeaway for Docker container networking is the paradigm of isolation by default. Containers must be explicitly connected to the same network to talk to each other; leverage this to easily improve the security of your applications.</p></li><li><p>Similarly, containers are not exposed on the external network by default; they must explicitly have ports mapped to the host if they are to be reachable by the outside world. Do not expose or map ports unnecessarily, as this leads to port conflicts and security risks!</p></li><li><p>For much more detail, see the corresponding reference architecture linked below.</p></li></ul></div></aside></div></section><section id="_further_reading_5"><h2>Further reading</h2><div class="slide-content"><div class="ulist"><ul><li><p>Docker Reference: Designing Scalable, Portable Container Networks: <a href="https://dockr.ly/2q3O8jq">https://dockr.ly/2q3O8jq</a></p></li><li><p>Network containers: <a href="http://dockr.ly/2x1BYgW">http://dockr.ly/2x1BYgW</a></p></li><li><p>Docker container networking: <a href="http://dockr.ly/1QnT6y8">http://dockr.ly/1QnT6y8</a></p></li><li><p>Understand container communication: <a href="http://dockr.ly/2iSrHO0">http://dockr.ly/2iSrHO0</a></p></li></ul></div>
<aside class="notes"><div class="paragraph"><p>additional resources about networking basics</p></div></aside></div></section></section>
<section><section id="_introduction_to_container_compose"><h2>Introduction to container compose</h2></section><section id="_discussion_processes_vs_applications"><h2>Discussion: Processes vs. applications</h2><div class="slide-content"><div class="paragraph"><p>Containers and images describe individual processes.<br>
What will we need to describe entire applications?</p></div>
<aside class="notes"><div class="ulist"><ul><li><p>Lead class to the simple answer (some sort of manifest file that describes the application, in the spirit of deploy scripts or infrastructure-as-code), as well as the more substantial answer of some way to manage a living application, where 'manage' in this context means scale, route traffic, deploy and upgrade.</p></li><li><p>Hint questions if the class is stuck:</p></li><li><p>It&#8217;s not enough just to 'describe' an application - we need to make the deployment of those applications reproducible and portable. How? (someone should think of some sort of script).</p></li><li><p>Are applications static after they&#8217;re launched? What if load changes? (leads to thinking about scaling).</p></li><li><p>After scaling an application, how do we make sure traffic gets to the new instances of our app? Re-do service discovery? Reconfigure load balancers? We&#8217;d rather have something a little more transparent.</p></li></ul></div></aside></div></section><section id="_learning_objectives_6"><h2>Learning objectives</h2><div class="slide-content"><div class="paragraph"><p>By the end of this module, trainees will be able to</p></div>
<div class="ulist"><ul><li><p>Design scalable Docker services</p></li><li><p>Leverage Docker&#8217;s built in service discovery mechanism</p></li><li><p>Write a compose file describing an application</p></li></ul></div></div></section><section id="_distributed_application_architecture"><h2>Distributed application architecture</h2><div class="slide-content"><div class="ulist"><ul><li><p>Applications consisting of one or more containers across one or more nodes</p></li><li><p>Docker Compose facilitates multi-container design <span class="keyword">on a single node</span></p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>At this point, we&#8217;ve seen that Docker can provide adequately portable and isolated containers, and we&#8217;ve seen some basic nuts and bolts regarding how those containers can be networked together; we&#8217;re now ready to start exploring our first orchestration tool for making a true distributed application.</p></li><li><p>Ultimately, we&#8217;ll want to be able to completely decentralize our application, be networking many containers together across many hosts; for now, we&#8217;ll just solve half the problem, by making an application out of many containers, still all on the same host. We&#8217;ll relax the single-host constraint in the next chapter.</p></li></ul></div></aside></div></section><section id="_container_services"><h2>Container services</h2><div class="slide-content"><div class="ulist"><ul><li><p>Goal: declare and (re)configure many similar containers all at once</p></li><li><p>Goal: scale apps by adding containers seamlessly</p></li><li><p>A service defines the desired state of a group of identically configured containers</p></li><li><p>Docker provides transparent service discovery for Services</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>So far, we&#8217;ve declared containers one at a time with <code>docker container run&#8230;&#8203;</code>, and we&#8217;ve seen how to network individual containers together. This all works, but doesn&#8217;t scale conveniently.</p></li><li><p>Since we&#8217;re going to start designing apps to consist of potentially many containers, we&#8217;d like to be able to create and reconfigure containers en masse.</p></li><li><p>Furthermore, we need to put some thought into how discovery will work in this paradigm; if we scale up an app by declaring more containers, how will they all find out about each other and network themselves together</p></li><li><p>To address this problem, Docker orchestration introduces the idea of services. A service defines the desired state of a collection of identically configured containers, allowing us to declare a batch of containers all at once, and reconfigure them later by updating the service definition.</p></li><li><p>Furthermore, Docker provides out-of-the-box service discovery for services, automatically providing and configuring the networking necessary for these groups of containers to interact.</p></li></ul></div></aside></div></section><section id="_service_discovery"><h2>Service discovery</h2><div class="slide-content"><div class="imageblock"><img src="assets/images/10_compose/service-discovery.svg" alt="service discovery"></div>
<div class="paragraph"><p>Services are assigned a <span class="keyword">Virtual IP</span> which spreads traffic out across the underlying container automatically.</p></div>
<aside class="notes"><div class="ulist"><ul><li><p>Formerly, we may have had individual processes or containers communicating directly; this isn&#8217;t practical for a service we want to scale into many processes on demand.</p></li><li><p>To address this, Docker assigns a virtual IP to every service, and maintains a DNS lookup table on the host, so that at the application logic level, traffic can be directed to a service as a whole; load balancing to the underlying containers is handled by Docker&#8217;s onboard VIP server.</p></li><li><p>In this way, we can change the number of containers provisioned by a service without needing to do any explicit service discovery in our applications; the application logic sends traffic to the service regardless of how many containers it has provisioned, and Docker does the rest.</p></li></ul></div></aside></div></section><section id="_our_application_dockercoins" class="columns"><h2>Our application: Dockercoins</h2><div class="slide-content"><div class="paragraph column"><p><span class="image"><img src="assets/images/10_compose/dockercoins.png" alt="dockercoins" width="50%"></span><br>
(DockerCoins 2016 logo courtesy of <span class="keyword">@XtlCnslt</span> and <span class="keyword">@ndeloof</span>. Thanks!)</p></div>
<div class="paragraph column"><p>It is a Dockercoin miner!<br>
💰🐳📦🚢<br>
with 5 services:
<span class="image"><img src="assets/images/10_compose/dockercoins-flow.svg" alt="dockercoins flow"></span></p></div></div></section><section id="_instructor_demo_docker_compose" class="dark_background demo background"><h2><span class="icon moby_icon"><img src="assets/icons/task.png" alt="task"></span> Instructor demo: Docker-Compose</h2><div class="slide-content"><div class="paragraph"><p>See the demo</p></div>
<div class="ulist"><ul><li><p>Docker Compose</p></li></ul></div>
<div class="paragraph"><p>in the exercise book.</p></div></div></section><section id="_exercise_compose_apps" class="dark_background exercise background"><h2><span class="icon moby_icon"><img src="assets/icons/task.png" alt="task"></span> Exercise: Compose apps</h2><div class="slide-content"><div class="paragraph"><p>Work through</p></div>
<div class="ulist"><ul><li><p>Starting a Compose App</p></li><li><p>Scaling s Compose App</p></li></ul></div>
<div class="paragraph"><p>in the exercise book.</p></div>
<h2 id="exercise_compose_app" class="timer"></h2></div></section><section id="_container_compose_takeaways"><h2>Container Compose takeaways</h2><div class="slide-content"><div class="ulist"><ul><li><p>Docker Compose makes single node orchestration easy</p></li><li><p>Compose services makes scaling applications easy</p></li><li><p>Bottleneck identification important</p></li><li><p>Syntactically: <span class="keyword">docker-compose.yml</span> + API</p></li></ul></div>
<aside class="notes"><div class="ulist"><ul><li><p>Compose should be your go-to native Docker solution for orchestrating services and containers on a single node.</p></li><li><p>In the next section, we&#8217;ll learn how to do the same across many nodes.</p></li></ul></div></aside></div></section><section id="_further_reading_6"><h2>Further reading</h2><div class="slide-content"><div class="ulist"><ul><li><p>Docker compose examples: <a href="http://dockr.ly/1FL2VQ6">http://dockr.ly/1FL2VQ6</a></p></li><li><p>Overview of docker-compose CLI: <a href="http://dockr.ly/2wtQlZT">http://dockr.ly/2wtQlZT</a></p></li><li><p>docker-compose.yaml reference: <a href="http://dockr.ly/2iHUpeX">http://dockr.ly/2iHUpeX</a></p></li><li><p>Docker Compose and Windows: <a href="http://bit.ly/2watrqk">http://bit.ly/2watrqk</a></p></li></ul></div>
<aside class="notes"><div class="paragraph"><p>additional resources about Docker compose</p></div></aside></div></section></section>
<section><section id="_wrapup_dontainer_compose_sonarqube"><h2>Wrapup Dontainer Compose - Sonarqube</h2></section><section id="_sonarqube"><h2>Sonarqube</h2><div class="slide-content"><div class="imageblock"><img src="assets/images/11_compose_wrap_up/sonarqube.png" alt="sonarqube" width="50%"></div></div></section><section id="_exercise_instructions_2" class="dark_background exercise background"><h2><span class="icon moby_icon"><img src="assets/icons/task.png" alt="task"></span> Exercise: Instructions</h2><div class="slide-content"><div class="ulist"><ul><li><p>Setup a Sonarqube server that listens on port 9000</p></li><li><p>Connect it to a persistent database</p></li><li><p>Use postgresql and persist it‘s data on the host filesystem using volumes</p></li><li><p>Verify that the data is persistent (create user and delete the container)</p></li><li><p>Check that Sonarqube is really using your postgresql database</p></li><li><p>Hint: use docker-compose</p></li></ul></div>
<h2 id="exercise_compose_app" class="timer"></h2>
<aside class="notes"><div class="paragraph"><p>heck that Sonarqube is really using your postgresql database:
* login to postgres container
* psql sonar sonar
* \l - list all existing databases
* \dt - list all tables of databases
* <strong>Hint</strong>: Postgresql tips at <a href="http://www.unixwitch.de/de/sysadmin/tools/postgres">http://www.unixwitch.de/de/sysadmin/tools/postgres</a></p></div></aside></div></section><section id="_solution_2"><h2>Solution</h2><div class="slide-content"><div class="listingblock"><div class="content"><pre class="highlightjs highlight"><code class="language-yaml hljs" data-noescape="true" data-lang="yaml">version: "2"
services:
  sonarqube:
    image: sonarqube
    ports:
      - "9000:9000"
    networks:
      - sonarnet
    environment:
      - SONARQUBE_JDBC_URL=jdbc:postgresql://db:5432/sonar
    volumes:
      - sonarqube_conf:/opt/sonarqube/conf
      - sonarqube_data:/opt/sonarqube/data
      - sonarqube_extensions:/opt/sonarqube/extensions
      - sonarqube_bundled-plugins:/opt/sonarqube/lib/bundled-plugins
  db:
    image: postgres
    networks:
      - sonarnet
    environment:
      - POSTGRES_USER=sonar
      - POSTGRES_PASSWORD=sonar
    volumes:
      - postgresql:/var/lib/postgresql
      - postgresql_data:/var/lib/postgresql/datanetworks
    sonarnet:
      driver: bridge
volumes:
  sonarqube_conf:
  sonarqube_data:
  sonarqube_extensions:
  sonarqube_bundled-plugins:
  postgresql:
  postgresql_data:</code></pre></div></div></div></section></section>
<section id="_containerization_training"><h2>Containerization Training</h2><div class="slide-content"><div class="paragraph"><p>Please take our feedback survey</p></div>
<div class="paragraph"><p>Get in touch: <span class="keyword">office@gepardec.com</span></p></div>
<div class="paragraph"><p><a href="https://www.gepardec.com/trainings">https://www.gepardec.com/trainings</a></p></div></div></section><p
    style="font-size:12px !important; z-index:10; color:rgb(0, 0, 0); position: fixed; bottom: 1px; left: calc(50% - 8em);">
    <i>#WECKDENGEPARDENINDIR</i>
</p>
<script src="assets/js/timer.js"></script></div></div><script src="node_modules/reveal.js/dist/reveal.js"></script><script>Array.prototype.slice.call(document.querySelectorAll('.slides section')).forEach(function(slide) {
  if (slide.getAttribute('data-background-color')) return;
  // user needs to explicitly say he wants CSS color to override otherwise we might break custom css or theme (#226)
  if (!(slide.classList.contains('canvas') || slide.classList.contains('background'))) return;
  var bgColor = getComputedStyle(slide).backgroundColor;
  if (bgColor !== 'rgba(0, 0, 0, 0)' && bgColor !== 'transparent') {
    slide.setAttribute('data-background-color', bgColor);
    slide.style.backgroundColor = 'transparent';
  }
});

// More info about config & dependencies:
// - https://github.com/hakimel/reveal.js#configuration
// - https://github.com/hakimel/reveal.js#dependencies
Reveal.initialize({
  // Display presentation control arrows
  controls: true,
  // Help the user learn the controls by providing hints, for example by
  // bouncing the down arrow when they first encounter a vertical slide
  controlsTutorial: true,
  // Determines where controls appear, "edges" or "bottom-right"
  controlsLayout: 'bottom-right',
  // Visibility rule for backwards navigation arrows; "faded", "hidden"
  // or "visible"
  controlsBackArrows: 'faded',
  // Display a presentation progress bar
  progress: true,
  // Display the page number of the current slide
  slideNumber: false,
  // Control which views the slide number displays on
  showSlideNumber: 'all',
  // Add the current slide number to the URL hash so that reloading the
  // page/copying the URL will return you to the same slide
  hash: true,
  // Push each slide change to the browser history. Implies `hash: true`
  history: false,
  // Enable keyboard shortcuts for navigation
  keyboard: true,
  // Enable the slide overview mode
  overview: true,
  // Disables the default reveal.js slide layout so that you can use custom CSS layout
  disableLayout: false,
  // Vertical centering of slides
  center: true,
  // Enables touch navigation on devices with touch input
  touch: true,
  // Loop the presentation
  loop: false,
  // Change the presentation direction to be RTL
  rtl: false,
  // See https://github.com/hakimel/reveal.js/#navigation-mode
  navigationMode: 'default',
  // Randomizes the order of slides each time the presentation loads
  shuffle: false,
  // Turns fragments on and off globally
  fragments: true,
  // Flags whether to include the current fragment in the URL,
  // so that reloading brings you to the same fragment position
  fragmentInURL: false,
  // Flags if the presentation is running in an embedded mode,
  // i.e. contained within a limited portion of the screen
  embedded: false,
  // Flags if we should show a help overlay when the questionmark
  // key is pressed
  help: true,
  // Flags if speaker notes should be visible to all viewers
  showNotes: false,
  // Global override for autolaying embedded media (video/audio/iframe)
  // - null: Media will only autoplay if data-autoplay is present
  // - true: All media will autoplay, regardless of individual setting
  // - false: No media will autoplay, regardless of individual setting
  autoPlayMedia: null,
  // Global override for preloading lazy-loaded iframes
  // - null: Iframes with data-src AND data-preload will be loaded when within
  //   the viewDistance, iframes with only data-src will be loaded when visible
  // - true: All iframes with data-src will be loaded when within the viewDistance
  // - false: All iframes with data-src will be loaded only when visible
  preloadIframes: null,
  // Number of milliseconds between automatically proceeding to the
  // next slide, disabled when set to 0, this value can be overwritten
  // by using a data-autoslide attribute on your slides
  autoSlide: 0,
  // Stop auto-sliding after user input
  autoSlideStoppable: true,
  // Use this method for navigation when auto-sliding
  autoSlideMethod: Reveal.navigateNext,
  // Specify the average time in seconds that you think you will spend
  // presenting each slide. This is used to show a pacing timer in the
  // speaker view
  defaultTiming: 120,
  // Specify the total time in seconds that is available to
  // present.  If this is set to a nonzero value, the pacing
  // timer will work out the time available for each slide,
  // instead of using the defaultTiming value
  totalTime: 0,
  // Specify the minimum amount of time you want to allot to
  // each slide, if using the totalTime calculation method.  If
  // the automated time allocation causes slide pacing to fall
  // below this threshold, then you will see an alert in the
  // speaker notes window
  minimumTimePerSlide: 0,
  // Enable slide navigation via mouse wheel
  mouseWheel: false,
  // Hide cursor if inactive
  hideInactiveCursor: true,
  // Time before the cursor is hidden (in ms)
  hideCursorTime: 5000,
  // Hides the address bar on mobile devices
  hideAddressBar: true,
  // Opens links in an iframe preview overlay
  // Add `data-preview-link` and `data-preview-link="false"` to customise each link
  // individually
  previewLinks: false,
  // Transition style (e.g., none, fade, slide, convex, concave, zoom)
  transition: 'slide',
  // Transition speed (e.g., default, fast, slow)
  transitionSpeed: 'default',
  // Transition style for full page slide backgrounds (e.g., none, fade, slide, convex, concave, zoom)
  backgroundTransition: 'fade',
  // Number of slides away from the current that are visible
  viewDistance: 3,
  // Number of slides away from the current that are visible on mobile
  // devices. It is advisable to set this to a lower number than
  // viewDistance in order to save resources.
  mobileViewDistance: 3,
  // Parallax background image (e.g., "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'")
  parallaxBackgroundImage: '',
  // Parallax background size in CSS syntax (e.g., "2100px 900px")
  parallaxBackgroundSize: '',
  // Number of pixels to move the parallax background per slide
  // - Calculated automatically unless specified
  // - Set to 0 to disable movement along an axis
  parallaxBackgroundHorizontal: null,
  parallaxBackgroundVertical: null,
  // The display mode that will be used to show slides
  display: 'block',

  // The "normal" size of the presentation, aspect ratio will be preserved
  // when the presentation is scaled to fit different resolutions. Can be
  // specified using percentage units.
  width: "100%",
  height: "100%",

  // Factor of the display size that should remain empty around the content
  margin: 0.05,

  // Bounds for smallest/largest possible scale to apply to content
  minScale: 0.2,
  maxScale: 2.0,

  // PDF Export Options
  // Put each fragment on a separate page
  pdfSeparateFragments: true,
  // For slides that do not fit on a page, max number of pages
  pdfMaxPagesPerSlide: 1,

  // Optional libraries used to extend on reveal.js
  dependencies: [
      { src: 'node_modules/reveal.js/plugin/zoom/zoom.js', async: true, callback: function () { Reveal.registerPlugin(RevealZoom) } },
      { src: 'node_modules/reveal.js/plugin/notes/notes.js', async: true, callback: function () { Reveal.registerPlugin(RevealNotes) } }
  ],
});</script><script>var dom = {};
dom.slides = document.querySelector('.reveal .slides');

function getRemainingHeight(element, slideElement, height) {
  height = height || 0;
  if (element) {
    var newHeight, oldHeight = element.style.height;
    // Change the .stretch element height to 0 in order find the height of all
    // the other elements
    element.style.height = '0px';
    // In Overview mode, the parent (.slide) height is set of 700px.
    // Restore it temporarily to its natural height.
    slideElement.style.height = 'auto';
    newHeight = height - slideElement.offsetHeight;
    // Restore the old height, just in case
    element.style.height = oldHeight + 'px';
    // Clear the parent (.slide) height. .removeProperty works in IE9+
    slideElement.style.removeProperty('height');
    return newHeight;
  }
  return height;
}

function layoutSlideContents(width, height) {
  // Handle sizing of elements with the 'stretch' class
  toArray(dom.slides.querySelectorAll('section .stretch')).forEach(function (element) {
    // Determine how much vertical space we can use
    var limit = 5; // hard limit
    var parent = element.parentNode;
    while (parent.nodeName !== 'SECTION' && limit > 0) {
      parent = parent.parentNode;
      limit--;
    }
    if (limit === 0) {
      // unable to find parent, aborting!
      return;
    }
    var remainingHeight = getRemainingHeight(element, parent, height);
    // Consider the aspect ratio of media elements
    if (/(img|video)/gi.test(element.nodeName)) {
      var nw = element.naturalWidth || element.videoWidth, nh = element.naturalHeight || element.videoHeight;
      var es = Math.min(width / nw, remainingHeight / nh);
      element.style.width = (nw * es) + 'px';
      element.style.height = (nh * es) + 'px';
    } else {
      element.style.width = width + 'px';
      element.style.height = remainingHeight + 'px';
    }
  });
}

function toArray(o) {
  return Array.prototype.slice.call(o);
}

Reveal.addEventListener('slidechanged', function () {
  layoutSlideContents("100%", "100%")
});
Reveal.addEventListener('ready', function () {
  layoutSlideContents("100%", "100%")
});
Reveal.addEventListener('resize', function () {
  layoutSlideContents("100%", "100%")
});</script><link rel="stylesheet" href="assets/highlight/styles/base16/solarized-light.min.css"/>
<script src="assets/highlight/highlight.min.js"></script>
<script src="assets/highlight/languages/yaml.min.js"></script>
<script src="assets/highlight/languages/bash.min.js"></script>
<script src="assets/highlight/languages/shell.min.js"></script>
<script src="assets/highlight/languages/dockerfile.min.js"></script>

<script>

/* highlightjs-line-numbers.js 2.6.0 | (C) 2018 Yauheni Pakala | MIT License | github.com/wcoder/highlightjs-line-numbers.js */
/* Edited by Hakim for reveal.js; removed async timeout */
!function(n,e){"use strict";function t(){var n=e.createElement("style");n.type="text/css",n.innerHTML=g(".{0}{border-collapse:collapse}.{0} td{padding:0}.{1}:before{content:attr({2})}",[v,L,b]),e.getElementsByTagName("head")[0].appendChild(n)}function r(t){"interactive"===e.readyState||"complete"===e.readyState?i(t):n.addEventListener("DOMContentLoaded",function(){i(t)})}function i(t){try{var r=e.querySelectorAll("code.hljs,code.nohighlight");for(var i in r)r.hasOwnProperty(i)&&l(r[i],t)}catch(o){n.console.error("LineNumbers error: ",o)}}function l(n,e){"object"==typeof n&&f(function(){n.innerHTML=s(n,e)})}function o(n,e){if("string"==typeof n){var t=document.createElement("code");return t.innerHTML=n,s(t,e)}}function s(n,e){e=e||{singleLine:!1};var t=e.singleLine?0:1;return c(n),a(n.innerHTML,t)}function a(n,e){var t=u(n);if(""===t[t.length-1].trim()&&t.pop(),t.length>e){for(var r="",i=0,l=t.length;i<l;i++)r+=g('<tr><td class="{0}"><div class="{1} {2}" {3}="{5}"></div></td><td class="{4}"><div class="{1}">{6}</div></td></tr>',[j,m,L,b,p,i+1,t[i].length>0?t[i]:" "]);return g('<table class="{0}">{1}</table>',[v,r])}return n}function c(n){var e=n.childNodes;for(var t in e)if(e.hasOwnProperty(t)){var r=e[t];h(r.textContent)>0&&(r.childNodes.length>0?c(r):d(r.parentNode))}}function d(n){var e=n.className;if(/hljs-/.test(e)){for(var t=u(n.innerHTML),r=0,i="";r<t.length;r++){var l=t[r].length>0?t[r]:" ";i+=g('<span class="{0}">{1}</span>\n',[e,l])}n.innerHTML=i.trim()}}function u(n){return 0===n.length?[]:n.split(y)}function h(n){return(n.trim().match(y)||[]).length}function f(e){e()}function g(n,e){return n.replace(/{(\d+)}/g,function(n,t){return e[t]?e[t]:n})}var v="hljs-ln",m="hljs-ln-line",p="hljs-ln-code",j="hljs-ln-numbers",L="hljs-ln-n",b="data-line-number",y=/\r\n|\r|\n/g;n.hljs?(n.hljs.initLineNumbersOnLoad=r,n.hljs.lineNumbersBlock=l,n.hljs.lineNumbersValue=o,t()):n.console.error("highlight.js not detected!")}(window,document);

/**
 * This reveal.js plugin is wrapper around the highlight.js
 * syntax highlighting library.
 */
(function( root, factory ) {
  if (typeof define === 'function' && define.amd) {
    root.RevealHighlight = factory();
  } else if( typeof exports === 'object' ) {
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    root.RevealHighlight = factory();
  }
}( this, function() {

  // Function to perform a better "data-trim" on code snippets
  // Will slice an indentation amount on each line of the snippet (amount based on the line having the lowest indentation length)
  function betterTrim(snippetEl) {
    // Helper functions
    function trimLeft(val) {
      // Adapted from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/Trim#Polyfill
      return val.replace(/^[\s\uFEFF\xA0]+/g, '');
    }
    function trimLineBreaks(input) {
      var lines = input.split('\n');

      // Trim line-breaks from the beginning
      for (var i = 0; i < lines.length; i++) {
        if (lines[i].trim() === '') {
          lines.splice(i--, 1);
        } else break;
      }

      // Trim line-breaks from the end
      for (var i = lines.length-1; i >= 0; i--) {
        if (lines[i].trim() === '') {
          lines.splice(i, 1);
        } else break;
      }

      return lines.join('\n');
    }

    // Main function for betterTrim()
    return (function(snippetEl) {
      var content = trimLineBreaks(snippetEl.innerHTML);
      var lines = content.split('\n');
      // Calculate the minimum amount to remove on each line start of the snippet (can be 0)
      var pad = lines.reduce(function(acc, line) {
        if (line.length > 0 && trimLeft(line).length > 0 && acc > line.length - trimLeft(line).length) {
          return line.length - trimLeft(line).length;
        }
        return acc;
      }, Number.POSITIVE_INFINITY);
      // Slice each line with this amount
      return lines.map(function(line, index) {
        return line.slice(pad);
      })
        .join('\n');
    })(snippetEl);
  }

  var RevealHighlight = {

    HIGHLIGHT_STEP_DELIMITER: '|',
    HIGHLIGHT_LINE_DELIMITER: ',',
    HIGHLIGHT_LINE_RANGE_DELIMITER: '-',

    init: function( reveal ) {

      // Read the plugin config options and provide fallbacks
      var config = Reveal.getConfig().highlight || {};
      config.highlightOnLoad = typeof config.highlightOnLoad === 'boolean' ? config.highlightOnLoad : true;
      config.escapeHTML = typeof config.escapeHTML === 'boolean' ? config.escapeHTML : true;

      [].slice.call( reveal.getRevealElement().querySelectorAll( 'pre code' ) ).forEach( function( block ) {

        block.parentNode.className = 'code-wrapper';

        // Code can optionally be wrapped in script template to avoid
        // HTML being parsed by the browser (i.e. when you need to
        // include <, > or & in your code).
        let substitute = block.querySelector( 'script[type="text/template"]' );
        if( substitute ) {
          // textContent handles the HTML entity escapes for us
          block.textContent = substitute.innerHTML;
        }

        // Trim whitespace if the "data-trim" attribute is present
        if( block.hasAttribute( 'data-trim' ) && typeof block.innerHTML.trim === 'function' ) {
          block.innerHTML = betterTrim( block );
        }

        // Escape HTML tags unless the "data-noescape" attrbute is present
        if( config.escapeHTML && !block.hasAttribute( 'data-noescape' )) {
          block.innerHTML = block.innerHTML.replace( /</g,"&lt;").replace(/>/g, '&gt;' );
        }

        // Re-highlight when focus is lost (for contenteditable code)
        block.addEventListener( 'focusout', function( event ) {
          hljs.highlightElement( event.currentTarget );
        }, false );

        if( config.highlightOnLoad ) {
          RevealHighlight.highlightBlock( block );
        }
      } );

      // If we're printing to PDF, scroll the code highlights of
      // all blocks in the deck into view at once
      reveal.on( 'pdf-ready', function() {
        [].slice.call( reveal.getRevealElement().querySelectorAll( 'pre code[data-line-numbers].current-fragment' ) ).forEach( function( block ) {
          RevealHighlight.scrollHighlightedLineIntoView( block, {}, true );
        } );
      } );
    },

    /**
     * Highlights a code block. If the <code> node has the
     * 'data-line-numbers' attribute we also generate slide
     * numbers.
     *
     * If the block contains multiple line highlight steps,
     * we clone the block and create a fragment for each step.
     */
    highlightBlock: function( block ) {

      hljs.highlightElement( block );

      // Don't generate line numbers for empty code blocks
      if( block.innerHTML.trim().length === 0 ) return;

      if( block.hasAttribute( 'data-line-numbers' ) ) {
        hljs.lineNumbersBlock( block, { singleLine: true } );

        var scrollState = { currentBlock: block };

        // If there is at least one highlight step, generate
        // fragments
        var highlightSteps = RevealHighlight.deserializeHighlightSteps( block.getAttribute( 'data-line-numbers' ) );
        if( highlightSteps.length > 1 ) {

          // If the original code block has a fragment-index,
          // each clone should follow in an incremental sequence
          var fragmentIndex = parseInt( block.getAttribute( 'data-fragment-index' ), 10 );

          if( typeof fragmentIndex !== 'number' || isNaN( fragmentIndex ) ) {
            fragmentIndex = null;
          }

          // Generate fragments for all steps except the original block
          highlightSteps.slice(1).forEach( function( highlight ) {

            var fragmentBlock = block.cloneNode( true );
            fragmentBlock.setAttribute( 'data-line-numbers', RevealHighlight.serializeHighlightSteps( [ highlight ] ) );
            fragmentBlock.classList.add( 'fragment' );
            block.parentNode.appendChild( fragmentBlock );
            RevealHighlight.highlightLines( fragmentBlock );

            if( typeof fragmentIndex === 'number' ) {
              fragmentBlock.setAttribute( 'data-fragment-index', fragmentIndex );
              fragmentIndex += 1;
            }
            else {
              fragmentBlock.removeAttribute( 'data-fragment-index' );
            }

            // Scroll highlights into view as we step through them
            fragmentBlock.addEventListener( 'visible', RevealHighlight.scrollHighlightedLineIntoView.bind( Plugin, fragmentBlock, scrollState ) );
            fragmentBlock.addEventListener( 'hidden', RevealHighlight.scrollHighlightedLineIntoView.bind( Plugin, fragmentBlock.previousSibling, scrollState ) );

          } );

          block.removeAttribute( 'data-fragment-index' )
          block.setAttribute( 'data-line-numbers', RevealHighlight.serializeHighlightSteps( [ highlightSteps[0] ] ) );

        }

        // Scroll the first highlight into view when the slide
        // becomes visible. Note supported in IE11 since it lacks
        // support for Element.closest.
        var slide = typeof block.closest === 'function' ? block.closest( 'section:not(.stack)' ) : null;
        if( slide ) {
          var scrollFirstHighlightIntoView = function() {
            RevealHighlight.scrollHighlightedLineIntoView( block, scrollState, true );
            slide.removeEventListener( 'visible', scrollFirstHighlightIntoView );
          }
          slide.addEventListener( 'visible', scrollFirstHighlightIntoView );
        }

        RevealHighlight.highlightLines( block );

      }

    },

    /**
     * Animates scrolling to the first highlighted line
     * in the given code block.
     */
    scrollHighlightedLineIntoView: function( block, scrollState, skipAnimation ) {

      cancelAnimationFrame( scrollState.animationFrameID );

      // Match the scroll position of the currently visible
      // code block
      if( scrollState.currentBlock ) {
        block.scrollTop = scrollState.currentBlock.scrollTop;
      }

      // Remember the current code block so that we can match
      // its scroll position when showing/hiding fragments
      scrollState.currentBlock = block;

      var highlightBounds = RevealHighlight.getHighlightedLineBounds( block )
      var viewportHeight = block.offsetHeight;

      // Subtract padding from the viewport height
      var blockStyles = getComputedStyle( block );
      viewportHeight -= parseInt( blockStyles.paddingTop ) + parseInt( blockStyles.paddingBottom );

      // Scroll position which centers all highlights
      var startTop = block.scrollTop;
      var targetTop = highlightBounds.top + ( Math.min( highlightBounds.bottom - highlightBounds.top, viewportHeight ) - viewportHeight ) / 2;

      // Account for offsets in position applied to the
      // <table> that holds our lines of code
      var lineTable = block.querySelector( '.hljs-ln' );
      if( lineTable ) targetTop += lineTable.offsetTop - parseInt( blockStyles.paddingTop );

      // Make sure the scroll target is within bounds
      targetTop = Math.max( Math.min( targetTop, block.scrollHeight - viewportHeight ), 0 );

      if( skipAnimation === true || startTop === targetTop ) {
        block.scrollTop = targetTop;
      }
      else {

        // Don't attempt to scroll if there is no overflow
        if( block.scrollHeight <= viewportHeight ) return;

        var time = 0;
        var animate = function() {
          time = Math.min( time + 0.02, 1 );

          // Update our eased scroll position
          block.scrollTop = startTop + ( targetTop - startTop ) * RevealHighlight.easeInOutQuart( time );

          // Keep animating unless we've reached the end
          if( time < 1 ) {
            scrollState.animationFrameID = requestAnimationFrame( animate );
          }
        };

        animate();

      }

    },

    /**
     * The easing function used when scrolling.
     */
    easeInOutQuart: function( t ) {

      // easeInOutQuart
      return t<.5 ? 8*t*t*t*t : 1-8*(--t)*t*t*t;

    },

    getHighlightedLineBounds: function( block ) {

      var highlightedLines = block.querySelectorAll( '.highlight-line' );
      if( highlightedLines.length === 0 ) {
        return { top: 0, bottom: 0 };
      }
      else {
        var firstHighlight = highlightedLines[0];
        var lastHighlight = highlightedLines[ highlightedLines.length -1 ];

        return {
          top: firstHighlight.offsetTop,
          bottom: lastHighlight.offsetTop + lastHighlight.offsetHeight
        }
      }

    },

    /**
     * Visually emphasize specific lines within a code block.
     * This only works on blocks with line numbering turned on.
     *
     * @param {HTMLElement} block a <code> block
     * @param {String} [linesToHighlight] The lines that should be
     * highlighted in this format:
     * "1" 		= highlights line 1
     * "2,5"	= highlights lines 2 & 5
     * "2,5-7"	= highlights lines 2, 5, 6 & 7
     */
    highlightLines: function( block, linesToHighlight ) {

      var highlightSteps = RevealHighlight.deserializeHighlightSteps( linesToHighlight || block.getAttribute( 'data-line-numbers' ) );

      if( highlightSteps.length ) {

        highlightSteps[0].forEach( function( highlight ) {

          var elementsToHighlight = [];

          // Highlight a range
          if( typeof highlight.end === 'number' ) {
            elementsToHighlight = [].slice.call( block.querySelectorAll( 'table tr:nth-child(n+'+highlight.start+'):nth-child(-n+'+highlight.end+')' ) );
          }
          // Highlight a single line
          else if( typeof highlight.start === 'number' ) {
            elementsToHighlight = [].slice.call( block.querySelectorAll( 'table tr:nth-child('+highlight.start+')' ) );
          }

          if( elementsToHighlight.length ) {
            elementsToHighlight.forEach( function( lineElement ) {
              lineElement.classList.add( 'highlight-line' );
            } );

            block.classList.add( 'has-highlights' );
          }

        } );

      }

    },

    /**
     * Parses and formats a user-defined string of line
     * numbers to highlight.
     *
     * @example
     * RevealHighlight.deserializeHighlightSteps( '1,2|3,5-10' )
     * // [
     * //   [ { start: 1 }, { start: 2 } ],
     * //   [ { start: 3 }, { start: 5, end: 10 } ]
     * // ]
     */
    deserializeHighlightSteps: function( highlightSteps ) {

      // Remove whitespace
      highlightSteps = highlightSteps.replace( /\s/g, '' );

      // Divide up our line number groups
      highlightSteps = highlightSteps.split( RevealHighlight.HIGHLIGHT_STEP_DELIMITER );

      return highlightSteps.map( function( highlights ) {

        return highlights.split( RevealHighlight.HIGHLIGHT_LINE_DELIMITER ).map( function( highlight ) {

          // Parse valid line numbers
          if( /^[\d-]+$/.test( highlight ) ) {

            highlight = highlight.split( RevealHighlight.HIGHLIGHT_LINE_RANGE_DELIMITER );

            var lineStart = parseInt( highlight[0], 10 ),
              lineEnd = parseInt( highlight[1], 10 );

            if( isNaN( lineEnd ) ) {
              return {
                start: lineStart
              };
            }
            else {
              return {
                start: lineStart,
                end: lineEnd
              };
            }

          }
          // If no line numbers are provided, no code will be highlighted
          else {

            return {};

          }

        } );

      } );

    },

    /**
     * Serializes parsed line number data into a string so
     * that we can store it in the DOM.
     */
    serializeHighlightSteps: function( highlightSteps ) {

      return highlightSteps.map( function( highlights ) {

        return highlights.map( function( highlight ) {

          // Line range
          if( typeof highlight.end === 'number' ) {
            return highlight.start + RevealHighlight.HIGHLIGHT_LINE_RANGE_DELIMITER + highlight.end;
          }
          // Single line
          else if( typeof highlight.start === 'number' ) {
            return highlight.start;
          }
          // All lines
          else {
            return '';
          }

        } ).join( RevealHighlight.HIGHLIGHT_LINE_DELIMITER );

      } ).join( RevealHighlight.HIGHLIGHT_STEP_DELIMITER );

    }

  }

  Reveal.registerPlugin( 'highlight', RevealHighlight );

  return RevealHighlight;

}));
        
hljs.configure({
  ignoreUnescapedHTML: true,
});
hljs.highlightAll();
</script></body></html>