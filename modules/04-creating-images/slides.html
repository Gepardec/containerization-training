<section>
    <section class="no_bg">
        <h2>Creating Images</h2>

        <aside class="notes">
            <ul>
                <li>In our discussion of containers, we focused on how processes are isolated.</li>
                <li>But if a process is to be truly portable, it also needs its filesystem and dependencies to come along with it.</li>
                <li>In this module, we'll explore images in-depth, including a focus on creating and modifying images.</li>
            </ul>
        </aside>
    </section>

    <section class="no_bg">
        <h2>Discussion: Provisioning Filesystems</h2>

        <p>What are some potential difficulties with provisioning entire filesystems for containers? How can we avoid these problems?</p>

        <aside class='notes'>
            <ul>
                <li>Guide the class to thinking about some of the non-obvious nuances around building and sharing images</li>
                <li>Obvious answer: disk and bandwidth usage</li>
                <li>Hint questions if the class is stuck:</li>
                <li>Are all container filesystems necessarily unique? If two containers share a filesystem, how will they remain independent? (leads to layer sharing and read-only images)</li>
                <li>What's a simple way to minimize the risk of vulnerable components making it onto your production servers via a Docker image? (answer: don't install any component you don't absolutely need, indicates the logic of minimal images)</li>
                <li>If containers and their filesystems are meant to move across environments like dev, testing, staging and prod without needing to be modified, how can they reflect the important differences between those environments? (leads to motivating multi-stage builds)</li>
            </ul>
        </aside>

    </section>

    <section class="no_bg">
        <h2>Learning Objectives</h2>

        <p>By the end of this module, learners will be able to</p>
        <ul>
            <li>Create images via several methods</li>
            <li>Describe the filesystem structure underlying an image</li>
            <li>Understand the performance implications of different image design decisions</li>
            <li>Correctly tag and namespace images for distribution on a registry</li>
        </ul>
    </section>

    <section class="no_bg">
        <h2>What are Images?</h2>

        <div class='row'>
            <div class='col-6'>
                <ul>
                    <li>A <span class="keyword">filesystem</span> for container process</li>
                    <li>Made of a stack of <span class="keyword">immutable</span> layers</li>
                    <li>Start with a <span class="keyword">base image</span></li>
                    <li>New layer for each change</li>
                </ul>
            </div>
            <div class='col-6' style='text-align:right'>
                <img src='images/image-layered-fs.svg' height="95%" width="auto"/>
            </div>            
        </div>

        <aside class="notes">
            <ul>
                <li>Images are composed in layers; each layer consists of a bunch of files that capture how this layer adapts the one beneath it.</li>
                <li>Note: On Windows there are also Windows registy entries that are captured as part of the layer.</li>
                <li>These stacks of layers always start with a base image, which typically captures only the base operating system for this image.</li>
                <li>each subsequent image layer captures sequential changes to the image.</li>
            </ul>
        </aside>
    </section>

    <section class="no_bg">
        <h2>Sharing Layers</h2>

        <img src='images/image-shared-layers.svg' height="95%" width="auto"/>

        <aside class="notes">
            <p>benefits of layering: (see if students can guess):</p>
            <ul>
                <li>Sharing layers == smaller on disk and in memory</li>
                <li>Sharing layers == faster downloads (de-duped by default)</li>
                <li>Allows caching when constructing images</li>
            </ul>
        </aside>
    </section>

    <section class="no_bg">
        <h2>The Writable Container Layer</h2>

        <img src='images/image-container-layer.svg' height="95%" width="auto"/>

        <aside class="notes">
            <ul>
                <li>Starting a container essentially adds a single writable layer to the image stack; since Docker is just adding this one thin layer, container startup is very fast and resource efficient.</li>
                <li>Any manipulations of the filesystem a container does is written only to this R/W layer; all image layers are always read-only.</li>
                <li>When a container edits a file from the base image, then and only then is that file copied to the R/W layer; this is what is meant by Docker's 'copy on write' filesystem; this also implies that the copy of a file that is visible in a running container is whichever copy of that file sits highest in the stack of filesystem layers.</li>
            </ul>
        </aside>
    </section>

    <section class="no_bg">
        <h2>Images: Copy on Write</h2>

        <img src='images/image-copy-on-write.svg' height="95%" width="auto"/>

        <aside class='notes'>
            <ul>
                <li>The final product is composed per this diagram, via what we call a 'copy on write' composition strategy</li>
                <li>Each time a layer is added, only files that are changed are copied up to the next layer; each of these layers actually exists as a directory on your host machine.</li>
            </ul>
        </aside>
    </section>
    
    <section class="no_bg">
        <h2>Linux Containers: Union FS</h2>

        <img src='images/image-union-fs.svg' height="95%" width="auto"/>

        <aside class='notes'>
            <ul>
                <li>When creating a container on Linux, a R/W container layer is created, and all these filesystem layers are composed via a union filesystem mount. This assembles the image layers into a unified filesystem similar to superimposing a stack of overhead transparencies on top of each other; files on higher layers obscure earlier versions of themselves on lower layers.</li>
                <li>When a container modifies a file from the image, it performs the same copy on write action as above, into the R/W container layer.</li>
            </ul>
        </aside>

    </section>

    <!--
    <section class="no_bg">
        <h2>Windows Containers: Linked FS</h2>

        <img src='images/windows-fs.png' style='width:70%'></img>

        <aside class='notes'>
            <ul>
                <li>On the Windows side, making union file systems backwards compatible with NTFS wasn't feasible.</li>
                <li>Instead, Windows uses reparse points to effectively link the appropriate image files into a container layer; if a file is unmodified in the layer, a stub is created for it containing the reparse point. Actually, each image layer also contains reparse points to earlier reparse points, in a chain down to the original file.</li>
                <li>When a Windows container changes a file in an image, it's copied to the virtual hard drive where the changes can be made.</li>
            </ul>
        </aside>
    </section>
    -->
    
    <section class="no_bg">
        <h2>Creating Images</h2>
        <p>Three methods:</p>
        <ul>
            <li><span class="keyword">Commit</span> the R/W container layer as a new R/O image layer.</li>
            <li>Define new layers to add to a starting image in a <span class="keyword">Dockerfile</span>.</li>
            <li><span class="keyword">Import</span> a tarball into Docker as a standalone base layer.</li>
        </ul>
    </section>

    <section class="no_bg">
        <h2>Committing Container Changes</h2>
        <ul>
            <li><code>docker container commit</code><br>saves container layer as new R/O image layer</li>
            <li>Pro: build images interactively</li>
            <li>Con: hard to reproduce or audit; <span class='keyword'>avoid this</span> in practice.</li>
        </ul>

        <aside class='notes'>
            <ul>
                <li>One way of building up images is to save the container layer as a new image layer</li>
                <li>This is fine for experiments, but it's really something best avoided in the development of production grade code, since it isn't easily auditable, reproducible or automated.</li>
            </ul>
        </aside>
    </section>

    <section class="no_bg">
        <h2>Dockerfiles</h2>
        <ul>
            <li>Content manifest</li>
            <li>Provides image layer documentation</li>
            <li>Enables automation (CI/CD)</li>
        </ul>

        <aside class='notes'>
            <ul>
                <li>Interactive image creation is good for tinkering, but its main drawback is that it doesn't produce an artifact describing the steps to create the image in a machine-readable way.</li>
                <li>Therefore, there's no way to build images this way as part of a CI/CD chain, and it can be hard to audit what exactly is in the image.</li>
                <li>A Dockerfile is essentially a recipe to build an image, layer by layer. This can be ingested in build processes and CI/CD pipelines, and preserves a record of all the steps taken to create an image.</li>
            </ul>
        </aside>
    </section>

    <section class="no_bg">
        <h2>Dockerfiles</h2>
        <ul>
            <li><code>FROM</code> command defines base image.</li>
            <li>Each subsequent command adds a layer or metadata</li>
            <li><code>docker image build ...</code> builds image from Dockerfile</li>
        </ul>
        <br><br>
        <div class="row">
            <div class="col-6">
                <pre><code data-trim data-noescape># Comments begin with the pound sign
<span class="red-bg">FROM</span> ubuntu:16.04
<span class="red-bg">RUN</span> apt-get update &amp;&amp; apt-get install -y wget
<span class="red-bg">ADD</span> /data /myapp/data
...</code></pre>
            </div>
            <!--
            <div class="col-6">
                Windows containers:<br>
                <div class="pre"># Comments begin with the pound sign
<span class="red-bg">FROM</span> microsoft/nanoserver:latest
<span class="red-bg">RUN</span> Install-Module -Name Nuget -Force
<span class="red-bg">ADD</span> c:\\myapp\data c:\\app\data
...</div>
            </div>
        -->
        </div>

        <aside class='notes'>
            <ul>
                <li>Note that dockerfiles for linux and windows are syntactically identical; they use different images for their bases and run different processes at each step, but the way we specify our image recipe doesn't change at all.</li>
            </ul>
        </aside>
    </section>

    <section data-background="#340B65" class="green_bg">
        <h2><img src="images/icon_task.png" class="moby_icon" alt="icon"> Instructor Demo: Creating Images</h2>

        <p>See the demo</p> 
        
        <ul>
            <li class='demo' script='creating-images-demo.md'>Creating Images</li>
        </ul>

        <p>In the Exercises book.</p>
    </section> 

    <section  data-background="#00a2a1" class="green_bg">
        <h2><img src="images/icon_task.png" class="moby_icon" alt="icon"> Exercises: Creating Images</h2>
        <p>Work through</p> 
        <ul>
            <li class='exercise' script='interactive-image-creation.md'>Interactive Image Creation</li>
            <li class='exercise' script='creating-images-with-dockerfiles-part-1.md'>Creating Images with Dockerfiles (1/2)</li>
        </ul>
        <p>in the Exercises book.<p>
        <h2 class="timer"></h2>
    </section> 
    
    <section class="no_bg">
        <h2>Build Cache</h2>
        <div class='row'> 
            <div class='col-4'>
                <img src='images/image-build-cache.svg' height="95%" width="auto"/>
            </div>
            <div class='col-8'>
                <ul>
                    <li>After completion, the resulting image layer is labeled with a hash of the content of all current image layers in the stack.</li>
                </ul>
            </div>
        </div>

        <aside class='notes'>
            <ul>
                <li>Layers are fetched from the cache via the hash label affixed to that layer the first time it was created.</li>
                <li>Q: Why is a hash for a layer computed based on the entire image? Why not just that layer?</li>
                <li>A: A layer can't be reused unless all layers under it are the same; put another way, the effect of whatever command generated the layer might be different depending on substrate layers.</li>
                <li>The upshot being that the builder will stop using the cache at the first change in the Dockerfile.</li>
            </ul>
        </aside>
    </section>

    <section class="no_bg">
        <h2>CMD and ENTRYPOINT</h2>
        <ul>
            <li>Recall all containers run a process as their PID 1</li>
            <li><code>CMD</code> and <code>ENTRYPOINT</code> allow us to specify default processes.</li>
        </ul>

        <aside class='notes'>
            <ul>
                <li>Another pair of helpful commands in Dockerfiles are CMD and ENTRYPOINT</li>
                <li>These are used for specifying default processes and options to run in containers created from this image.</li>
            </ul>
        </aside>
    </section>

    <section class="no_bg">
        <h2>CMD and ENTRYPOINT</h2>
        <ul>
            <li><code>CMD</code> alone: default command and list of parameters.</li>
            <li><code>CMD</code> + <code>ENTRYPOINT</code>: <code>ENTRYPOINT</code> provides command, <code>CMD</code> provides default parameters.</li>
            <li><code>CMD</code> overridden by command arguments to <code>docker container run</code>
            <li><code>ENTRYPOINT</code> overridden via <br><code>--entrypoint</code> flag to <code>docker container run</code>.</li>
        </ul>

        <aside class='notes'>
            <ul>
                <li>Oftentimes images are designed to do exactly one thing; CMD and ENTRYPOINT allow you to bake that intention right into the image, by pre-specifying that command.</li>
                <li>The difference between the two is essentially in how you want to override these defaults</li>
                <li>Using them together makes your container feel a lot like an executable; arguments (defaulted by CMD) will be overridden by command line args, but the executable defined by ENTRYPOINT will not.</li>
            </ul>
        </aside>
    </section>

    <section class="no_bg">
        <h2>Shell vs. exec format</h2>
        <div class="row">
            <div class="col-6">
                <div class='pre'># Shell form
CMD sudo -u ${USER} java ...

# Exec form
CMD ["sudo", "-u", "jdoe", "java", ...]</div>
            </div>
            <!--
            <div class="col-6">
                Windows containers:<br>
                <div class='pre'># shell form
CMD c:\\Apache24\\bin\\httpd.exe -w

# exec form
CMD ["c:\\Apache24\\bin\\httpd.exe", "-w"]</div>
                <p>Note the "\\" in the expressions</p>
            </div>
            -->
        </div>
        <aside class='notes'>
            <ul>
                <li>CMD, ENTRYPOINT and RUN commands can use either exec or shell syntax</li>
                <li>If we have a command like this on Windows `powershell New-Item c:\test` then if it is in declared in shell form what is executed is in reality `cmd /S /C powershell New-Item c:\test` whilst in exec form the command is executed as is without the use of the shell (cmd in this case). The analogous is true for Linux containers.</li>
                <li>exec is generally preferred for ENTRYPOINT, since it preserves the ability to override options.</li>
                <li>
                    subtle differences:
                    <ul>
                        <li><i>Shell form</i> allows for the parsing of variables like <code>CMD sudo -u ${USER} java ... </code></li>
                        <li><i>Exec form</i> can run in a container with no shell; shell form always runs via <code>/bin/sh -c</code></li>
                        <li><i>Shell form</i> for <code>ENTRYPOINT</code> prevents options from being overridden by <code>CMD</code> or <code>docker container run</code>.</li> 
                    </ul>
                </li>
                <li>Note that exec form is formal JSON - double quotes mandatory.</li>
                <li>When using the shell form, the specified binary is executed with an invocation of the shell using /bin/sh -c, which means the process running as PID 1 is the /bin/sh executable.</li>
            </ul>
        </aside>
    </section>

    <section data-background="#00a2a1" class="green_bg">
        <h2><img src="images/icon_task.png" class="moby_icon" alt="icon"> Exercise: Dockerfiles (2/2)</h2>

        <p>Work through</p> 
        <ul>
            <li class='exercise' script='creating-images-with-dockerfiles-part-2.md'>Creating Images with Dockerfiles (2/2)</li>
        </ul>

        <p>In the Exercises book.</p>
        <h2 class="timer"></h2>
    </section>

    <section class="no_bg">
        <h2>COPY and ADD commands</h2>

        <p><code>COPY</code> copies files from build context to image</p>
        <pre class='large'>COPY &lt;src&gt; &lt;dest&gt;</pre>

        <div>
            <p><code>ADD</code> can also <span class='keyword'>untar</span>* or <span class='keyword'>fetch URLs</span>.</p>
            <div style="font-style: italic; font-size: 0.5em !important; color:darkgrey !important;">* Linux containers only!</div>
        </div>    
        <p>In both cases</p>
        <ul>
            <li>create checksum for files added</li>
            <li>log checksum in build cache</li>
            <li>cache invalidated if checksum changed</li>
        </ul>

        <aside class='notes'>
            <ul>
                <li>COPY and ADD add files from the local filesystem to the image</li>
                <li>Build process uses a checksum against the files to be added to bust the cache if those files have changed</li>
                <li>Note that ADD can also copy files from a URL and for Linux containers only(!) untar files upon copying them into the image.</li>
            </ul>
        </aside>
    </section>

    <section class="no_bg">
        <h2>Dockerfile Command Roundup</h2>

        <ul>
            <li><span class='keyword'>FROM</span>: base image to start from (usually OS)</li>
            <li><span class='keyword'>RUN</span>: run a command in the environment defined so far</li>
            <li><span class='keyword'>CMD</span> and <span class='keyword'>ENTRYPOINT</span>: define default behavior</li>
            <li><span class='keyword'>COPY</span> and <span class='keyword'>ADD</span>: copy files into container</li>
        </ul>

        <p>Many more Dockerfile commands are available; see the docs at <a href="https://docs.docker.com/engine/reference/builder/"><span ></span>https://docs.docker.com/engine/reference/builder/</span></a></p>

        <aside class='notes'>
            <ul>
                <li>We've seen the greatest hits of Dockerfile commands, but there are tons more; see the docs.</li>
            </ul>
        </aside>

    </section>

    <section class="no_bg">
        <h2>Advanced Dockerfile Construction</h2>

        <p>How can we build images that are</p>

        <ul>
            <li>Lightweight</li>
            <li>Secure</li>
            <li>Minimal build times</li>
        </ul>

        <aside class='notes'>
            <ul>
                <li>Now that we've seen the basics of image construction with Dockerfiles, we'd like to investigate best practices around image construction</li>
                <li>Our priorities for image creation are size, security, and build times.</li>
                <li>Size and security can be addressed by similar techniques; making sure we only install things we absolutely need in our image not only keeps the image size down, but avoids exposing ourselves to potential vulnerabilities in superfluous components.</li>
                <li>Also during the course of development, we'd like build times to be as fast as possible, either by leveraging the cache we've already seen, or by parallelizing parts of the build process.</li>
                <li>For the next part of this chapter, we'll look at some advanced techniques for achieving all of these.</li>
            </ul>
        </aside>

    </section>

    <section class="no_bg">
        <h2>The Scratch Image</h2>
        <ul>
            <li>An "empty" image</li>
            <li>Can't be pulled</li>
            <li>Doesn't create a layer</li>
            <li>Used for building images not based on any pre-existing image</li>
            <li>Linux only</li>
        </ul>

        <div class='pre'>FROM <span class="red-bg">scratch</span>

ADD centos-7-docker.tar.xz /

LABEL org.label-schema.schema-version="1.0" \
org.label-schema.name="CentOS Base Image" \
org.label-schema.vendor="CentOS" \
org.label-schema.license="GPLv2" \
org.label-schema.build-date="20181205"

CMD ["/bin/bash"]</div>

        <aside class='notes'>
            <ul>
                <li>The scratch image is an empty image that exists in Docker Hub, but has no tags and can't be pulled.</li>
                <li>When used in a Dockerfile, the line `FROM scratch` doesn't add any layer to the image. The next command in the Dockerfile will be the first filesystem layer.</li>
                <li>The scratch image is used typically to build base images with as few components as possible installed in them, to give the smallest possible attack surface to our images.</li>
            </ul>
        </aside>
    </section>

    <section class="no_bg">
        <h2>Multi-Stage Builds</h2>

        <div class="row">
            <div class="col-6">
                <div style="font-size: 0.5em;">Hello World, in C:</div>
                <div class="pre">FROM alpine:3.5
RUN apk update &amp;&amp; \
    apk add --update alpine-sdk
RUN mkdir /app
WORKDIR /app
ADD hello.c /app
RUN mkdir bin
RUN gcc -Wall hello.c -o bin/hello 
CMD /app/bin/hello</div>
            </div>
            <!--
            <div class="col-6">
                Windows containers:<br>
                <div style="font-size: 0.5em;">Hello World, in Go:</div>
                <div class="pre">FROM golang:nanoserver</span>
COPY . /code
WORKDIR /code
RUN go build hello.go
CMD ["\\code\\hello.exe"]</div>
            </div>
-->
        </div>
        <br>
        <div style="font-size: 0.6em;">Builds to:</div>

        <pre>
$ docker image ls hwc
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hwc                 latest              142c29686b6a        15 hours ago        184 MB</pre>

        <aside class='notes'>
            <ul>
                <li>Here's a Dockerization of hello world, in C. By now, we should recognize the steps: we start from an operating system, use RUN to install dependencies, ADD to import files from our host machine, and define some default behavior with CMD.</li>
                <li>There's just one problem: we have successfully made a hello world application in a mere 184 MB. Giant images are at best slow to start, and can have security problems depending on what unnecessary components have been included.</li>
                <li>Most of this bloat is due to things we don't actually need in production: compilers, developer tools and the like.</li>
                <li>The Docker image builder implements Multi Stage Builds to allow you to create executables, then throw away the scaffolding needed to compile them, leaving you with a fast, lightweight image.</li>
            </ul>
        </aside>
    </section>    

    <section class="no_bg">
        <h2>Multi-Stage Builds</h2>

        <p>Hello World, lightweight:</p>

        <div class="row">
            <div class="col-6">
                <div class="pre"># Full SDK version (built and discarded)
FROM alpine:3.5 <span class="red-bg">AS build</span>
RUN apk update &amp;&amp; \
    apk add --update alpine-sdk
RUN mkdir /app
WORKDIR /app
ADD hello.c /app
RUN mkdir bin
RUN gcc -Wall hello.c -o bin/hello 

# Lightweight image returned as final product
FROM alpine:3.5
<span class="red-bg">COPY --from=build /app/bin/hello /app/hello</span>
CMD /app/hello</div>

            </div>
            <!--
            <div class="col-6">
                Windows containers:<br>
                <div class="pre">FROM golang:nanoserver <span class="red-bg">as gobuild</span>
COPY . /code
WORKDIR /code
RUN go build hello.go

FROM microsoft/nanoserver
<span class="red-bg">COPY --from=gobuild /code/hello.exe /hello.exe</span>
EXPOSE 8080
CMD ["\\hello.exe"]</div>
            </div>
    -->
        </div>
        <br>
        <div style="font-size: 0.6em;">Builds to:</div>
        <div class="pre">$ docker image ls hwc
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
hwc                 latest              5d925cfc9c96        39 seconds ago      <span class="red-bg">4MB</span></div>

        <aside class='notes'>
            <ul>
                <li>To make a lightweight version of hello world with all the developer tools stripped out, we start with the exact same Dockerfile, but we've added the AS clause to the FROM statement.</li>
                <li>Then, we've added a second stanza, where we start from the same OS, but instead of installing the developer's kit, we use the --from flag with COPY to reference the 'build' image described above, and copy just the final executable over into our final image.</li>
                <li>The --from flag to COPY can also also specify an earlier image by index counting from 0 (so --from=0 would have had the same effect in the second stanza above).</li>
                <li>Note that it kind of looks like we built two images here - in fact, only the final FROM stanza results in an image on disk. All previous stanzas create cached image layers, but no final image.</li>
            </ul>
        </aside>        
    </section>

    <section class="no_bg">   
        <h2>Build Targets</h2>
        <p>Dockerfile</p>
        <div><pre>FROM &lt;base image&gt; as base
...

FROM &lt;foo image&gt; as foo
...

FROM &lt;bar image&gt; as bar
...

FROM alpine:3.4
...
COPY --from foo ...
COPY --from bar ...
...</pre></div>  
        <p>Building the image</p>
        <code>docker image build --target &lt;name&gt; ...</code>

        <aside class="notes">
            <ul>
                <li>We can also build intermediate images by specifying the "--target" parameter with the name of the intermediate build.</li>
                <li>If no "--target" is provided then the "docker image build" command always builds only the last image (the one starting with the last FROM statement in the Dockerfile)</li>
                <li>The &lt;name&gt; of an intermediate image is either the index of the FROM in the Dockerfile or the alias provided in the FROM statement (e.g. FROM base as test - in that case &lt;name&gt; would be "test")</li>
            </ul>
        </aside>
    </section>

   <!--
       <section class="no_bg">
        <h2>BuildKit</h2>

        <ul>
            <li>Speed-optimized builder, enable via <code>export DOCKER_BUILDKIT=1</code></li>
            <li>Parallelizes multi-stage builds</li>
            <li>Custom frontends</li>
            <li>2x - 9x build speedup</li>
            <li>Linux only as of 18.09.0-ee</li>
        </ul>

        <aside class='notes'>
            <ul>
                <li>BuildKit is an optional builder designed to make the image building process faster, better optimized, and more customizable.</li>
                <li>BuildKit parallelizes multistage builds and introduces a number of behind-the-scenes optimizations for creating a greater than 2x speedup in build times.</li>
                <li>BuildKit also supports the creation of custom frontends that allow new features and customizations to be more easily integrated into the build process.</li>
            </ul>
        </aside>

    </section>
   --> 

    <section data-background="#00a2a1" class="green_bg">
        <h2><img src="images/icon_task.png" class="moby_icon" alt="icon"> Exercise: Multi-Stage Builds</h2>

        <p>Work through</p> 
        <ul>
            <li class='exercise' script='multi-stage-builds.md'>Multi-Stage Builds</li>
        </ul>

        <p>In the Exercises book.</p>
        <h2 class="timer"></h2>
    </section>

    <section class="no_bg">
        <h2>Image Construction Best Practices</h2>

        <ul>
            <li>Start with official images</li>
            <li>Use multi-stage builds to drop compilers, SDKs...</li>
            <li>More layers leverage the cache...</li>
            <li>...but fewer layers perform better.</li>
        </ul>

        <aside class='notes'>
            <ul>
                <li>Now that we have the mechanics of making Dockerfiles, there's also a number of optional best practices to consider.</li>
                <li>Base your images off of official images whenever possible; you can recognize these on Docker Hub as they don't have an explicit namespace like vendor/product; they're just single-word names, possibly with a tag. These are all battle-tested images produced in collaboration between the product vendors and Docker, and are scanned regularly for security vulnerabilities.</li>
                <li>Take advantage of multi-stage builds; these allow you to drop unnecessary layers, which will result in faster container start times, and less components that potentially inject vulnerabilities into your containers.</li>
                <li>Deciding how many layers to build an image out of depends on your priorities. The fundamental tension is that more layers leverage the cache better (since hopefully you don't invalidate the cache until you're most of the way through your Dockerfile), but this creates more overhead at container runtime, which you may wish to avoid for production images.</li>
            </ul>
        </aside>
    </section>

    <section class="no_bg">
        <h2>Development: More Layers</h2>

        <div class='row'>
            <div class='col-6'>
                <p>Bad caching:</p>
                <pre class='large'>
FROM python:3.5-alpine
RUN mkdir /app
<span class="red-bg">COPY /mypy /app/</span>
RUN pip install -r app/reqs.txt
...</pre>
            </div>
            <div class='col-6'>
                <p>Good caching:</p>
                <pre class='large'>
FROM python:3.5-alpine
RUN mkdir /app
<span class="red-bg">COPY /mypy/reqs.txt /app/</span>
RUN pip install -r app/reqs.txt
<span class="red-bg">COPY /mypy /app/</span>
...</pre>
            </div>
        </div>

        <aside class='notes'>
            <ul>
                <li>A common best practice during development is to split up oft-changing and rarely-changing elements into different layers. Move the rarely-changing parts as high as possible in the Dockerfile, so they don't have to be redone when the frequently changing parts are changed.</li>
                <li>In this case, we save ourselves from redoing the `pip install` when anything other than the requirements file changes.</li>
            </ul>
        </aside>

    </section>

    <section class="no_bg">
        <h2>Production: Less Layers</h2>

        <ul>
            <li>
                To collapse ALL image layers:
                <pre class='large'>
docker container run -d --name demo mytallimage:1.0
docker container export demo > image.tar
cat image.tar | docker image import - myflatimage:1.0</pre>
            </li>
            <li>Or build with <code>--squash</code> flag (experimental): compress all non-base layers</li>
            <li>Combine <code>container export</code> with <code>--squash</code> for one shareable base layer + one application-specific upper layer</li>
        </ul>

        <aside class='notes'>
            <ul>
                <li>Once it's time to go to production (or even to start CI/CD), we don't care so much about build times and caching. The image is nominally built - what matters is performance.</li>
                <li>One way to compress everything into a single layer is to export a container as a tarball, and reimport it as a new, single layer image. This completely destroys the ability of containers to share layers, though</li>
                <li>Another method is the experimental squash flag, which combines all non-base layers into a single layer. Now the base layer remains sharable, and our production image is only two layers.</li>
                <li>One technique for getting the best of both worlds when layer sharing is important is to use the first method to collapse all widely shared layers into a common base image, and then use the --squash flag on subsequent builds to squash the application-unique layers into a single application layer.</li>
            </ul>
        </aside>

    </section>

    <section class="no_bg">
        <h2>Best Practice: Patching &amp; Updates</h2>

        <img src="images/image-good-bad-layering.svg" height="95%" width="auto"/>
        <aside class="notes">
            <ul>
                <li>When revving an image, don't just apply patches on top of old images. If it's your base layer that's been revved, the vendor will likely release a new image corresponding to the new software version; update your Dockerfile and rebuild your image with the new base layer.</li>
                <li>The same logic holds true for updating other image layers; rebuild your image from its Dockerfile, pulling in the desired versions of your dependencies, rather than just installing patches on top of patches like you would for software installed on the host.</li>
                <li>Remember copy on write: when you apply a patch, it doesn't overwrite whatever its upgrading; all versions of all files are persisted in their entirety in an ever-growing image layer stack. This will bloat your images and slow down their performance.</li>
            </ul>
        </aside>
     </section>

    <section class="no_bg">
        <h2>Image Tags</h2>

        <ul>
            <li>Optional string after image name, separated by <code>:</code></li>
            <li><code>:latest</code> by default</li>
            <li>Same image with two tags shares same ID, image layers:</li>
        </ul>

        <pre>
$ docker image ls centos*
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
centos              7                   8140d0c64310        7 days ago          193 MB
$ docker image tag centos:7 centos:mytag
$ docker image ls centos*
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
centos              7                   8140d0c64310        7 days ago          193 MB
centos              mytag               8140d0c64310        7 days ago          193 MB</pre>

        <aside class='notes'>
            <ul>
                <li>In addition to the name of the image, images can be given an optional tag.</li>
                <li>Tags are often used to capture version number or base image distro.</li>
                <li>The tag will default to `latest` if omitted.</li>
                <li>Note that tags are essentially just pointers to an image which is uniquely identified by its ID; creating another tag pointing to the same image doesn't duplicate the image on disk, but just creates another reference to it.</li>
            </ul>
        </aside>

    </section>

    <section class="no_bg">
        <h2>Image Namespaces</h2>
        <p>Images exist in one of three namespaces:</p>
        <ul>
            <li>Root (<code>ubuntu</code>, <code>nginx</code>, <code>mongo</code>, <code>mysql</code>, ...)</li>
            <li>
                User / Org (<code>jdoe/myapp:1.1</code>, 
                <code>microsoft/nanoserver:latest</code>, ...)
            </li>
            <li>Registry (<code>FQDN/jdoe/myapp:1.1</code>, ...)</li>
        </ul>

        <aside class="notes">
            <ul>
                <li>Certified images produced in collaboration between Docker and third-party software vendors are given single-word names in the root namespace.</li>
                <li>Images meant to be shared on hub.docker.com are namespaced via the owning account, then the image name</li>
                <li>Images stored in docker trusted registry are similar to hub.docker.com names, but prefixed with the FQDN of the registry.</li>
            </ul>
        </aside>
    </section>

    <section class="no_bg">
        <h2>Image Tagging &amp; Namespacing</h2>

        <ul>
            <li>Tag on build:<br>
                <div class="pre large">docker image build -t myapp<span class="red-bg">:1.0</span> .</div>
            </li>
            <li>Retag an existing image:<br>
                <div class="pre large">docker image tag myapp:1.0 <span class="red-bg">me/myapp:2.0</span></div>
            </li>
            <li>Note <code>docker image tag</code> can set both tag and namespace.</li>
            <li>Names and tags are just pointers to image ID</li>
            <li>Image ID corresponds to immutable content addressable storage</li>
        </ul>

        <aside class="notes">
            <ul>
                <li>Images can be tagged on build or retagged at any time.</li>
                <li>Note that image layers are only stored once per machine; retagging or renaming an image does not duplicate the image layer.</li>
                <li>Always remember that an image must be namespaced correctly to push to a registry, whether it's hub.docker.com or Docker Trusted Registry.</li>
                <li>Finally, remember that docker registries all use content addressable storage models; image names and tags are really just human-friendly pointers to image IDs, which serve as the true address for immutable image information. As such, it is a good security strategy to pull by sha and not by tag; then you always know exactly what you're getting.</li>
            </ul>
        </aside>

    </section>

    <section class="no_bg">
        <h2>Sharing Images</h2>

        <ul>
            <li>
                Docker Hub
                <ul>
                    <li>Provides certified commercial and free software distributed as Docker Images</li>
                    <li>Shares community-generated images and content</li>
                </ul>
            </li>
        </ul>

        <aside class="notes">
            <ul>
                <li>Docker Hub allows you to access and share your public repositories with the Docker community at large. You can download two types of images from the Docker Hub: Docker Verified Images and Community/Hub images.</li>
                <li>Docker Hub is a cloud-based registry service which allows you to link to code repositories, build your images and test them, stores manually pushed images, and links to Docker Cloud so you can deploy images to your hosts. If you have built images, you can push them to a Docker Hub repository that you add to your Docker Hub user or organization account.</li>
            </ul>
        </aside>
    </section>

    <section data-background="#00a2a1" class="green_bg">
        <h2><img src="images/icon_task.png" class="moby_icon" alt="icon"> Exercise: Managing Images</h2>

        <p>Work through</p> 
        <ul>
            <li class='exercise' script='managing-images.md'>Managing Images</li>
        </ul>

        <p>In the Exercises book.</p>
        <h2 class="timer"></h2>
    </section> 

    <section class="no_bg">
        <h2>Image Creation Takeaways</h2>

        <ul>
            <li>Images are built out of read-only layers.</li>
            <li>Dockerfiles specify image layer contents.</li>
            <li>Key Dockerfile commands: <code>FROM</code>, <code>RUN</code>, <code>COPY</code> and <code>ENTRYPOINT</code></li>
            <li>Images must be namespaced according to where you intend on sharing them.</li>
        </ul>

    </section>

    <section class="no_bg">
        <h2>Further Reading</h2>
        <ul>
            <li>Best practices for writing Dockerfiles: <a href="http://dockr.ly/22WiJiO">http://dockr.ly/22WiJiO</a></li>
            <li>Use multi-stage builds: <a href="http://dockr.ly/2ewcUY3">http://dockr.ly/2ewcUY3</a></li>
            <li>More about images, containers, and storage drivers: <a href="http://dockr.ly/1TuWndC">http://dockr.ly/1TuWndC</a></li>
            <li>Details on image layering: <a href='https://bit.ly/2AHX7iW'>https://bit.ly/2AHX7iW</a></li>
            <li>Graphdriver plugins: <a href="http://dockr.ly/2eIVCab">http://dockr.ly/2eIVCab</a></li>
            <li>Docker Reference Architecture: An Intro to Storage Solutions for Docker CaaS: <a href="http://dockr.ly/2x8sBw2">http://dockr.ly/2x8sBw2</a></li>
            <li>How to select a storage driver: <a href="http://dockr.ly/2eDu8yO">http://dockr.ly/2eDu8yO</a></li>
            <li>Use the AUFS storage driver: <a href="http://dockr.ly/2jVc1Zz">http://dockr.ly/2jVc1Zz</a></li>
            <li>User guided caching in Docker: <a href="http://dockr.ly/2xKafPf">http://dockr.ly/2xKafPf</a></li>
        </ul>
        <aside class='notes'>
            <ul>
                <li>additional resources about creating images for Linux</li>
            </ul>
        </aside>
    </section>

    <!--
    <section class="no_bg">
        <h2>Further Reading 2/2</h2>
        <h3>Windows Containers:</h3>
        <ul>
            <li>Dockerfile on Windows: <a href="http://bit.ly/2waNvsS"><span class="link">http://bit.ly/2waNvsS</span></a></li>
            <li>Optimize Windows Dockerfiles: <a href="http://bit.ly/2whpfn7"><span class="link">http://bit.ly/2whpfn7</span></a></li>
            <li>Windows Container Samples:
                <ul>
                    <li> <a href="http://bit.ly/2wCrPXy"><span class="link">http://bit.ly/2wCrPXy</span></a></li>
                    <li> <a href="http://bit.ly/2ghRr5o"><span class="link">http://bit.ly/2ghRr5o</span></a></li>
                </ul>
            </li>
            <li>Powershell Tricks: <a href="http://bit.ly/2wb7Azn"><span class="link">http://bit.ly/2wb7Azn</span></a></li>
            <li>Multi-stage builds for Windows containers: <a href="http://bit.ly/2iBRmdN"><span class="link">http://bit.ly/2iBRmdN</span></a></li>
            <li>The SHELL command: <a href="http://dockr.ly/2whvyqZ"><span class="link">http://dockr.ly/2whvyqZ</span></a></li>
        </ul>
        <aside class='notes'>
            <ul>
                <li>additional resources about creating images for Windows</li>
            </ul>
        </aside>
    </section>
    -->
</section>
